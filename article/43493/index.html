<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>CMake学习笔记 | 行走的康康</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 6.1.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">CMake学习笔记</h1><a id="logo" href="/.">行走的康康</a><p class="description">静下心来,不要浮躁</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">CMake学习笔记</h1><div class="post-meta">2021-02-17<span> | </span><span class="category"><a href="/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">开发环境</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 1.7k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 6</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><p>什么是CMake?<br>你或许听过好几种 Make 工具，例如 <a target="_blank" rel="noopener" href="https://www.hahack.com/wiki/tools-makefile.html">GNU Make</a> ，QT 的 <a target="_blank" rel="noopener" href="http://qt-project.org/doc/qt-4.8/qmake-manual.html">qmake</a> ，微软的 <a target="_blank" rel="noopener" href="http://msdn.microsoft.com/en-us/library/ms930369.aspx">MS nmake</a>，BSD Make（<a target="_blank" rel="noopener" href="http://www.freebsd.org/doc/en/books/pmake/">pmake</a>），<a target="_blank" rel="noopener" href="http://makepp.sourceforge.net/">Makepp</a>，等等。这些 Make 工具遵循着不同的规范和标准，所执行的 Makefile 格式也千差万别。这样就带来了一个严峻的问题：如果软件想跨平台，必须要保证能够在不同平台编译。而如果使用上面的 Make 工具，就得为每一种标准写一次 Makefile ，这将是一件让人抓狂的工作。<strong>CMake 就是针对上面问题所设计的工具：它首先允许开发者编写一种平台无关的 CMakeList.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件</strong>，如 Unix 的 Makefile 或 Windows 的 Visual Studio 工程。从而做到“Write once, run everywhere”。显然，CMake 是一个比上述几种 make 更高级的编译配置工具。一些使用 CMake 作为项目架构系统的知名开源项目有 <a target="_blank" rel="noopener" href="http://www.vtk.org/">VTK</a>、<a target="_blank" rel="noopener" href="http://www.itk.org/">ITK</a>、<a target="_blank" rel="noopener" href="http://kde.org/">KDE</a>、<a target="_blank" rel="noopener" href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/modules/core/doc/intro.html">OpenCV</a>、<a target="_blank" rel="noopener" href="http://www.openscenegraph.org/">OSG</a> 等 <sup class="footnote-ref" style="box-sizing: border-box; font-size: 12.6px; line-height: 0; position: relative; vertical-align: baseline; top: -0.5em;"><a target="_blank" rel="noopener" href="https://www.hahack.com/codes/cmake/#fn1">[1]</a></sup>。</p>
<p>在 linux 平台下使用 CMake 生成 Makefile 并编译的流程如下：</p>
<ol>
<li>编写 CMake 配置文件 CMakeLists.txt 。</li>
<li>执行命令 <code>cmake PATH</code> 或者 <code>ccmake PATH</code> 生成 Makefile（<code>ccmake</code> 和 <code>cmake</code> 的区别在于前者提供了一个交互式的界面）。其中， <code>PATH</code> 是 CMakeLists.txt 所在的目录。</li>
<li>使用 <code>make</code> 命令进行编译。</li>
</ol>
<p>本文将从实例入手，一步步讲解 CMake 的常见用法，文中所有的实例代码可以在<a target="_blank" rel="noopener" href="https://github.com/wzpan/cmake-demo">这里</a>找到。如果你读完仍觉得意犹未尽，可以继续学习我在文章末尾提供的其他资源。</p>
<h1 id="简单实例-helloworld"><a href="#简单实例-helloworld" class="headerlink" title="简单实例-helloworld"></a>简单实例-helloworld</h1><ul>
<li>工程文件结构：</li>
</ul>
<img src="https://nas.littlekang.xyz:9000/markdown/2021-02/1319_0944-SWdRVTzlfwfZGN4V.jpg" style="zoom: 200%;" /> 

<ul>
<li>src源码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>CMakeLists</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span>(demo)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(main main.c)</span><br></pre></td></tr></table></figure>

<ul>
<li>编译<br>创建build目录，以便将cmake生成文件与源代码分开；<br>在build目录下执行<code>cmake ../</code></li>
</ul>
<h1 id="CMake交叉编译"><a href="#CMake交叉编译" class="headerlink" title="CMake交叉编译"></a>CMake交叉编译</h1><p><strong>对于交叉编译，CMake并不知道目标系统是什么，所以需要设置一些CMake变量来告知CMak</strong>e</p>
<ul>
<li>CMAKE_SYSTEM_NAME：即目标系统名，这里是Linux</li>
<li>CMAKE_SYSTEM_PROCESSOR ：目标系统的处理器名</li>
</ul>
<p>对于工具链，则是通过下面2个变量来定位，</p>
<ul>
<li>CMAKE_C_COMPILER：C编译器的可执行文件名称</li>
<li>CMAKE_CXX_COMPILER：C++编译器的可执行文件名称</li>
</ul>
<p>这些变量可以在调用CMake时通过命令行传递，但是这种做法容易出错，而且用起来不方便，所以CMake提供了工具链文件的方式来传递这些变量信息</p>
<p>这里编译为openwrt mips架构：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#openwrt_linux_setup.cmake</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_SYSTEM_NAME Linux)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_SYSTEM_PROCESSOR mips)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(tools /opt/openwrt_mt7688_gcc-<span class="number">4.8</span>/gcc-<span class="number">4.8</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_COMPILER <span class="variable">$&#123;tools&#125;</span>/bin/mipsel-openwrt-linux-gcc)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER <span class="variable">$&#123;tools&#125;</span>/bin/mipsel-openwrt-linux-g++)</span><br></pre></td></tr></table></figure>

<h1 id="交叉编译配置"><a href="#交叉编译配置" class="headerlink" title="交叉编译配置"></a>交叉编译配置</h1><p>CMake给交叉编译预留了一个很好的变量即<strong>CMAKE_TOOLCHAIN_FILE</strong>,它定义了一个文件的路径，这个文件即toolChain,里面set了一系列你需要改变的变量和属性，包括C_COMPILER,CXX_COMPILER,如果用Qt的话需要更改QT_QMAKE_EXECUTABLE以及如果用BOOST的话需要更改的BOOST_ROOT(具体查看相关Findxxx.cmake里面指定的路径)。CMake为了不让用户每次交叉编译都要重新输入这些命令，因此它带来toolChain机制，简而言之就是一个cmake脚本，内嵌了你需要改变以及需要set的所有交叉环境的设置。</p>
<p>这里面也牵扯了一些相关的变量设置,在这里简单介绍下几个比较重要的</p>
<p>1. <strong>CMAKE_SYSTEM_NAME</strong>: 即你目标机target所在的操作系统名称，比如ARM或者Linux你就需要写”Linux”, 如果Windows平台你就写”Windows”,如果你的嵌入式平台没有相关OS你即需要写成”Generic”, <strong>只有当CMAKE_SYSTEM_NAME这个变量被设置了，CMake才认为此时正在交叉编译</strong>，它会额外设置一个变量CMAKE_CROSSCOMPILING为TRUE.</p>
<p>2. <strong>CMAKE_C_COMPILER</strong>: 顾名思义，即C语言编译器，<strong>这里可以将变量设置成完整路径或者文件名</strong>，设置成完整路径有一个好处就是CMake会去这个路径下去寻找编译相关的其他工具比如linker,binutils等，如果你写的文件名带有arm-elf等等前缀，CMake会识别到并且去寻找相关的交叉编译器。</p>
<p>3. <strong>CMAKE_CXX_COMPILER</strong>: 同上，此时代表的是C++编译器。</p>
<p>4. <strong>CMAKE_FIND_ROOT_PATH</strong>: <strong>代表了一系列的相关文件夹路径的根路径的变更</strong>，比如你设置了&#x2F;opt&#x2F;arm&#x2F;,所有的Find_xxx.cmake都会优先根据这个路径下的&#x2F;usr&#x2F;lib,&#x2F;lib等进行查找，然后才会去你自己的&#x2F;usr&#x2F;lib和&#x2F;lib进行查找，如果你有一些库是不被包含在&#x2F;opt&#x2F;arm里面的，你也可以显示指定多个值给CMAKE_FIND_ROOT_PATH,比如<code>set(CMAKE_FIND_ROOT_PATH /opt/arm /opt/inst)</code></p>
<p>5.  <strong>CMAKE_FIND_ROOT_PATH_MODE_PROGRAM</strong>: 对FIND_PROGRAM()起作用，有三种取值，<strong>NEVER,ONLY,BOTH</strong>,第一个表示不在你CMAKE_FIND_ROOT_PATH下进行查找，第二个表示只在这个路径下查找，第三个表示先查找这个路径，再查找全局路径，对于这个变量来说，<strong>一般都是调用宿主机的程序，所以一般都设置成NEVER</strong></p>
<p>6. <strong>CMAKE_FIND_ROOT_PATH_MODE_LIBRARY</strong>: 对FIND_LIBRARY()起作用，表示在链接的时候的库的相关选项，<strong>因此这里需要设置成ONLY来保证我们的库是在交叉环境中找的</strong>.</p>
<p>7. <strong>CMAKE_FIND_ROOT_PATH_MODE_INCLUDE</strong>: 对FIND_PATH()和FIND_FILE()起作用，<strong>一般来说也是ONLY</strong>,如果你想改变，一般也是在相关的FIND命令中增加option来改变局部设置，有NO_CMAKE_FIND_ROOT_PATH,ONLY_CMAKE_FIND_ROOT_PATH,BOTH_CMAKE_FIND_ROOT_PATH</p>
<p>8. <strong>BOOST_ROOT</strong>： 对于需要boost库的用户来说，相关的boost库路径配置也需要设置，因此这里的路径即ARM下的boost路径，里面有include和lib。</p>
<p>9. <strong>QT_QMAKE_EXECUTABLE</strong>: 对于Qt用户来说，需要更改相关的qmake命令切换成嵌入式版本，因此这里需要指定成相应的qmake路径（指定到qmake本身）</p>
<h1 id="同一目录，多个源文件"><a href="#同一目录，多个源文件" class="headerlink" title="同一目录，多个源文件"></a>同一目录，多个源文件</h1><p><code>aux_source_directory</code> 命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。其语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aux_source_directory(&lt;dir&gt; &lt;variable&gt;)</span><br></pre></td></tr></table></figure>
<p>示例：<br><img src="https://nas.littlekang.xyz:9000/markdown/2021-02/1322_3836-mzgMadNOWZqvuOiY.jpg" style="zoom:200%;" /> </p>
<h1 id="多个目录，多个源文件"><a href="#多个目录，多个源文件" class="headerlink" title="多个目录，多个源文件"></a>多个目录，多个源文件</h1><p>对于这种情况，需要分别在项目<strong>根目录和子目录目录里各编写一个 CMakeLists.txt</strong> 文件。为了方便，我们可以先将子目录里的文件编译成静态库再由 main 函数调用；</p>
<p>示例：<br><img src="https://nas.littlekang.xyz:9000/markdown/2021-02/1322_4206-UAFiDDl6tzpNYGRq.jpg" style="zoom:200%;" /> </p>
<img src="https://nas.littlekang.xyz:9000/markdown/2021-02/1322_4336-xXV3JFlLStYyNXVy.jpg" style="zoom:200%;" /> 



<h1 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.hahack.com/codes/cmake/">CMake 入门实战</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weicao1990/article/details/51149381">CMake交叉编译配置</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/whahu1989/article/details/104114515">使用CMake交叉编译Arm Linux程序</a></p>
</blockquote>
</div><div class="tags"><a href="/tags/cmake/"><i class="fa fa-tag"></i>cmake</a><a href="/tags/makefile/"><i class="fa fa-tag"></i>makefile</a></div><div class="post-nav"><a class="pre" href="/article/40025/">UDP组播_多播学习笔记</a><a class="next" href="/article/32140/">C++如何导出dll</a></div><script src="https://utteranc.es/client.js" repo="echomlv/blog_comments" issue-term="title" theme="github-light" crossorigin="anonymous" async> </script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa fa-blind"> Contents </i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B-helloworld"><span class="toc-number">1.</span> <span class="toc-text">简单实例-helloworld</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CMake%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91"><span class="toc-number">2.</span> <span class="toc-text">CMake交叉编译</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E9%85%8D%E7%BD%AE"><span class="toc-number">3.</span> <span class="toc-text">交叉编译配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8C%E4%B8%80%E7%9B%AE%E5%BD%95%EF%BC%8C%E5%A4%9A%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">同一目录，多个源文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E7%9B%AE%E5%BD%95%EF%BC%8C%E5%A4%9A%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">5.</span> <span class="toc-text">多个目录，多个源文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E5%BC%95%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text">参考引用</span></a></li></ol></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">行走的康康.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" color="246,246,246" opacity="0.5" zIndex="-2" count="50" src="//cdn.jsdelivr.net/npm/canvas-nest.js/dist/canvas-nest.min.js"></script><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>
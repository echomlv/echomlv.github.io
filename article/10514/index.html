<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>u-boot学习笔记-relocate | 行走的康康</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 6.1.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">u-boot学习笔记-relocate</h1><a id="logo" href="/.">行走的康康</a><p class="description">静下心来,不要浮躁</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">u-boot学习笔记-relocate</h1><div class="post-meta">2022-04-01<span> | </span><span class="category"><a href="/categories/U-Boot/">U-Boot</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 7.1k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 35</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><p>u-boot的relocate是新版本u-boot开始有的一个功能，是指u-boot的重定向动作，将自身拷贝到sdram上的另外一个位置的动作。</p>
<p>新版u-boot跟老版u-boot不太一样的地方，新版u-boot不管u-boot的加载地址在哪里，启动后会计算出一个靠近sdram顶端的地址，将自身代码拷贝到该地址，继续运行。</p>
<span id="more"></span>
<h1 id="rerocate介绍"><a href="#rerocate介绍" class="headerlink" title="rerocate介绍"></a>rerocate介绍</h1><h2 id="relocate是什么"><a href="#relocate是什么" class="headerlink" title="relocate是什么"></a>relocate是什么</h2><p><strong>u-boot的relocate操作，是指u-boot的重定向动作</strong>。</p>
<p><strong>uboot自身镜像(拷贝)到内存中另外一个位置的动作</strong>。</p>
<h2 id="为什么需要relocate"><a href="#为什么需要relocate" class="headerlink" title="为什么需要relocate"></a>为什么需要relocate</h2><p>考虑的问题：</p>
<ul>
<li><p>绝大部分嵌入式处理器都是<code>哈佛结构</code>，数据空间和程序空间独立编址；<br>u-boot固件一般存放在内部norflash，或者上电时自动映射nandflash、MMC等外部存储设备到iROM;<br>数据变量一般使用内部iRAM，或者内部Cache等，一般iRAM等都很小，运行速度慢，也不能满足复杂程序的运行需求；所以，在DDR, SDRAM等初始化完成之后，u-boot将自身relocate到DDR，SDRAM中去运行；</p>
</li>
<li><p>考虑到后续的kernel是在DDR SDRAM的低端位置解压缩并执行的，为了避免麻烦，u-boot将使用DRAM的顶端地址，即<code>gd-&gt;ram_top</code>所代表的位置；</p>
</li>
<li><p>考虑到u-boot升级时，relocate之后，让从u-boot中升级u-boot成为可能，不然如果u-boot还是从norflash等中加载程序到iRAM中运行，当升级写入新u-boot固件到norflash中时，会导致程序cash掉，因为在运行时程序文件被修改覆盖；</p>
<blockquote>
<p>REF: <a target="_blank" rel="noopener" href="https://u-boot.denx.narkive.com/JVIH8BMp/why-relocate-it-self-to-ram-from-flash">why u-boot relocate it self to RAM from</a></p>
</blockquote>
</li>
</ul>
<h2 id="SPL和relocate的关系"><a href="#SPL和relocate的关系" class="headerlink" title="SPL和relocate的关系"></a>SPL和relocate的关系</h2><p>SPL的出现，是u-boot为了解决一些处理器，它的iROM很小，没有办法存储完整的u-boot固件。</p>
<p>所以使用SPL处理一些紧急的必须的初始化操作(大部分由汇编完成，少量c代码)，初始化内存(SDRAM，DDR等)，然后负责将u-boot拷贝到内存中，跳转到内存中运行。</p>
<p><strong>那么使用SPL之后是不是就不需要relocate了呢？</strong></p>
<p>按照我的理解是可以不需要的，不知道对不对？</p>
<p>假定SPL拷贝u-boot的目标地址和relocate的目标地址一样，这样的话，我的理解是不需要的。</p>
<p>那么看u-boot的代码，还是进行relocate的。在u-boot的代码框架里，SPL和u-boot是两个独立运行的程序，虽然他们共享源码的结构，通过宏来区分。我的理解u-boot的设计是为了兼容大部分处理器，所以这里还是进行了relocate，即因为不知道SPL拷贝到内存的地址是否是符合u-boot要求的。</p>
<p>这样看来SPL和relocate是为了解决不同的问题，他们既有一定的联系，又是相对比较独立的。</p>
<p><strong>新版本的u-boot，无论是否拷贝，都将u-boot relocate到sdram顶端地址。</strong></p>
<h1 id="relocate实现需要的条件"><a href="#relocate实现需要的条件" class="headerlink" title="relocate实现需要的条件"></a>relocate实现需要的条件</h1><h2 id="需要的条件"><a href="#需要的条件" class="headerlink" title="需要的条件"></a>需要的条件</h2><p><strong>At arch level</strong>: add linker flag -pie<br>添加链接标识 <code>-pie</code>用于生成位置无关代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">This causes the linker to generate fixup tables .rel.dyn and .dynsym,</span><br><span class="line">which must be applied to the relocated image before transferring</span><br><span class="line">control to it.</span><br><span class="line"> </span><br><span class="line">These fixups are described in the ARM ELF documentation as type 23</span><br><span class="line">(program-base-relative) and 2 (symbol-relative)</span><br></pre></td></tr></table></figure>

<p><strong>At cpu level</strong>: modify linker file and add a relocation and fixup loop</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">the linker file must be modified to include the .rel.dyn and .dynsym</span><br><span class="line">tables in the binary image, and to provide symbols for the relocation</span><br><span class="line">code to access these tables</span><br><span class="line"> </span><br><span class="line">The relocation and fixup loop must be executed after executing</span><br><span class="line">board_init_f at initial location and before executing board_init_r</span><br><span class="line">at final location.</span><br></pre></td></tr></table></figure>

<p><strong>At board level</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dram_init(): bd pointer is now at this point NOT accessible, so only</span><br><span class="line">detect the real dramsize, and store it in gd-&gt;ram_size. Bst detected</span><br><span class="line">with get_ram_size().</span><br></pre></td></tr></table></figure>

<p><strong>TODO:</strong> move also dram initialization there on boards where it is possible.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Setup of the the bd_t dram bank info is done in the new function</span><br><span class="line">dram_init_banksize() called after bd is accessible.</span><br></pre></td></tr></table></figure>

<p><strong>At lib level</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Board.c code is adapted from ppc code</span><br></pre></td></tr></table></figure>

<p>** WARNING **<br>Boards which are not fixed to support relocation will be REMOVED!</p>
<hr>
<p>For boards which boot from spl, it is possible to save one copy<br>对于从SPL启动的，当<code>CONFIG_SYS_TEXT_BASE</code>和relocate目标地址相等时，可以不进行再次拷贝</p>
<p>if <code>CONFIG_SYS_TEXT_BASE</code> &#x3D;&#x3D; relocation address! This prevents that uboot code<br>is copied again in relocate_code().</p>
<blockquote>
<p>REF: <a target="_blank" rel="noopener" href="https://github.com/ARM-software/u-boot/blob/master/doc/README.arm-relocation">https://github.com/ARM-software/u-boot/blob/master/doc/README.arm-relocation</a></p>
</blockquote>
<h2 id="位置无关代码的原理"><a href="#位置无关代码的原理" class="headerlink" title="位置无关代码的原理"></a>位置无关代码的原理</h2><p>生成位置无关代码步骤：</p>
<ul>
<li><p>首先是编译源文件的时候，需要将其编译成位置无关代码，主要通过gcc的<code>-fpic</code>选项（也有可能是<code>fPIC</code>,<code>fPIE</code>, <code>mword-relocations</code>选项）</p>
</li>
<li><p>其次是连接时要将其连接成一个完整的位置无关的可执行文件，主要通过ld的<code>-fpie</code>选项</p>
</li>
</ul>
<p>ARM如何生成位置无关代码：</p>
<p>由于使用pic时movt &#x2F; movw指令会硬编码16bit的地址域，而uboot的relocation并不支持这个，<br><strong>所以arm平台使用mword-relocations来生成位置无关代码。-fno-pic则表示不使用pic。</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#arch/arm/config.mk</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># The movt / movw can hardcode 16 bit parts of the addresses in the</span></span><br><span class="line"><span class="comment"># instruction. Relocation is not supported for that case, so disable</span></span><br><span class="line"><span class="comment"># such usage by requiring word relocations.</span></span><br><span class="line">PLATFORM_CPPFLAGS += <span class="variable">$(<span class="built_in">call</span> cc-option, -mword-relocations)</span></span><br><span class="line">PLATFORM_CPPFLAGS += <span class="variable">$(<span class="built_in">call</span> cc-option, -fno-pic)</span></span><br></pre></td></tr></table></figure>

<h2 id="rel-dyn段简单介绍"><a href="#rel-dyn段简单介绍" class="headerlink" title=".rel .dyn段简单介绍"></a>.rel .dyn段简单介绍</h2><p>对于一些绝对地址符号（例如已经初始化的全局变量），会将其以label的形式放在每个函数的代码实现的末端。<br>在链接的过程中，会把这些label的地址统一维护在.rel.dyn段中，当relocation的时候，方便对这些地址的fix。</p>
<p>这块只是看懂了个粗略的，没有更深入的去分析，这块可以参考：<a target="_blank" rel="noopener" href="https://blog.css8.cn/post/2583310.html">https://blog.css8.cn/post/2583310.html</a></p>
<p>为了更方便分析汇编代码，这里将优化关掉了：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#顶层Makefile</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">ifdef</span> CONFIG_CC_OPTIMIZE_FOR_SIZE</span><br><span class="line">KBUILD_CFLAGS    += -O0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">KBUILD_CFLAGS    += -O0</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p>在<code>common/board_f.c</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">init_fnc_t</span> init_sequence_f[] = &#123;</span><br><span class="line">    setup_mon_len,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_OF_CONTROL</span></span><br><span class="line">    fdtdec_setup,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRACE</span></span><br><span class="line">    trace_early_init,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    initf_malloc,</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> board_init_f(ulong boot_flags)</span><br><span class="line">&#123;</span><br><span class="line">    gd-&gt;flags = boot_flags;</span><br><span class="line">    gd-&gt;have_console = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    asm_puts(<span class="string">&quot;will board_init_f()...\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//init_sequence_f是一个指针数组，里面存放各初始化函数的函数指针</span></span><br><span class="line">    <span class="comment">//是一个已初始化的全局变量</span></span><br><span class="line">    <span class="keyword">if</span> (initcall_run_list(init_sequence_f))</span><br><span class="line">        hang();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>arm-linux-gnueabi-objdump -D -S u-boot &gt;dump</code>反汇编u-boot elf文件, 查找对应的汇编代码</p>
<img src="https://nas.littlekang.xyz:9000/markdown/2022-03/3000_2549-ZkCtdn7uXPgPcQtV.png" alt="image-20220330002548843" style="zoom:200%;" />

<img src="https://nas.littlekang.xyz:9000/markdown/2022-03/3000_4157-P2bTCM59TECYKQEp.png" alt="image-20220330004157730" style="zoom:200%;" />

 

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">void board_init_f(ulong boot_flags)</span><br><span class="line">&#123;</span><br><span class="line">#压栈操作</span><br><span class="line"> 5fe0dbb8:   e92d4800    push    &#123;fp, lr&#125;</span><br><span class="line"> 5fe0dbbc:   e28db004    add fp, sp, #4</span><br><span class="line"> 5fe0dbc0:   e24dd008    sub sp, sp, #8</span><br><span class="line"> 5fe0dbc4:   e50b0008    str r0, [fp, #-8]</span><br><span class="line"> </span><br><span class="line">#gd结构的首地址存放在r9</span><br><span class="line">     gd-&gt;flags = boot_flags;</span><br><span class="line"> 5fe0dbc8:   e1a02009    mov r2, r9</span><br><span class="line"> 5fe0dbcc:   e51b3008    ldr r3, [fp, #-8]</span><br><span class="line"> 5fe0dbd0:   e5823004    str r3, [r2, #4]</span><br><span class="line"> </span><br><span class="line">     gd-&gt;have_console = 0;</span><br><span class="line"> 5fe0dbd4:   e1a02009    mov r2, r9</span><br><span class="line"> 5fe0dbd8:   e3a03000    mov r3, #0</span><br><span class="line"> 5fe0dbdc:   e582301c    str r3, [r2, #28]</span><br><span class="line"> </span><br><span class="line">     asm_puts(&quot;will board_init_f()...\n&quot;);</span><br><span class="line"> 5fe0dbe0:   e59f0024    ldr r0, [pc, #36]   ; 5fe0dc0c &lt;board_init_f+0x54&gt;</span><br><span class="line"> 5fe0dbe4:   ebffd214    bl  5fe0243c &lt;asm_puts&gt;</span><br><span class="line"> </span><br><span class="line">#由于ARM的流水线机制，当前PC值为当前地址加8个字节, 即当前PC=0x5fe0 dbf0</span><br><span class="line">#ldr r0,[pc, #32]表示将0x5fe0 dc10地址处的内容赋值给r0,</span><br><span class="line">#而0x5fe5 90c4正是init_sequence_f的地址，所以取得了init_sequence_f的地址</span><br><span class="line">     if (initcall_run_list(init_sequence_f))</span><br><span class="line"> 5fe0dbe8:   e59f0020    ldr r0, [pc, #32]   ; 5fe0dc10 &lt;board_init_f+0x58&gt;</span><br><span class="line"> 5fe0dbec:   eb00a3ee    bl  5fe36bac &lt;initcall_run_list&gt;</span><br><span class="line"> 5fe0dbf0:   e1a03000    mov r3, r0</span><br><span class="line"> 5fe0dbf4:   e3530000    cmp r3, #0</span><br><span class="line"> 5fe0dbf8:   0a000000    beq 5fe0dc00 &lt;board_init_f+0x48&gt;</span><br><span class="line">         hang();</span><br><span class="line"> 5fe0dbfc:   eb00ca87    bl  5fe40620 &lt;hang&gt;</span><br><span class="line">         !defined(CONFIG_EFI_APP) &amp;&amp; !CONFIG_IS_ENABLED(X86_64) &amp;&amp; \</span><br><span class="line">         !defined(CONFIG_ARC)</span><br><span class="line">     /* NOTREACHED - jump_to_copy() does not return */</span><br><span class="line">     hang();</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"> 5fe0dc00:   e1a00000    nop         ; (mov r0, r0)</span><br><span class="line"> 5fe0dc04:   e24bd004    sub sp, fp, #4</span><br><span class="line"> 5fe0dc08:   e8bd8800    pop &#123;fp, pc&#125;</span><br><span class="line"> 5fe0dc0c:   5fe51950    svcpl   0x00e51950</span><br><span class="line">#通过5fe0dc10找到init_sequence_f的地址</span><br><span class="line"> 5fe0dc10:   5fe590c4    svcpl   0x00e590c4</span><br></pre></td></tr></table></figure>

<h1 id="relocate代码分析"><a href="#relocate代码分析" class="headerlink" title="relocate代码分析"></a>relocate代码分析</h1><h2 id="gd结构体分析"><a href="#gd结构体分析" class="headerlink" title="gd结构体分析"></a>gd结构体分析</h2><p>gd就是指u-boot里面大名鼎鼎的<code>global_data</code>结构体，那么为什么会需要这样一个结构体呢？</p>
<p>要理解global data的意义，需要先理解如下的事实：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">u-boot是一个bootloader，有些情况下，它可能位于系统的只读存储器（ROM或者flash）中，并从那里开始执行。</span><br><span class="line"> </span><br><span class="line">因此，这种情况下，在u-boot执行的前期（在将自己copy到可读写的存储器之前），它所在的存储空间，是不可写的，这会有两个问题：</span><br><span class="line">1）堆栈无法使用，无法执行函数调用，也即C环境不可用。</span><br><span class="line">2）没有data段（或者正确初始化的data段）可用，不同函数或者代码之间，无法通过全局变量的形式共享数据。</span><br></pre></td></tr></table></figure>

<p>对于问题1，通常的解决方案是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u-boot运行起来之后，在那些不需要执行任何初始化动作即可使用的、可读写的存储区域，开辟一段堆栈（stack）空间。</span><br><span class="line">一般来说，大部分的平台（如很多ARM平台），都有自己的SRAM，可用作堆栈空间。</span><br><span class="line">如果实在不行，也有可借用CPU的data cache的方法（不再过多说明）。</span><br></pre></td></tr></table></figure>

<p>对于问题2，解决方案要稍微复杂一些：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">首先，对于开发者来说，在u-boot被拷贝到可读写的RAM（这个动作称作relocation）之前，永远不要使用全局变量。</span><br><span class="line">其次，在relocation之前，不同模块之间，确实有通过全局变量的形式传递数据的需求。怎么办？这就是global data需要解决的事情。</span><br></pre></td></tr></table></figure>

<p>u-boot是如何解决的?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">为了在relocation前通过全局变量的形式传递数据，u-boot设计了一个巧妙的方法：</span><br><span class="line"> </span><br><span class="line">1）定义一个struct global_data类型的数据结构，里面保存了各色各样需要传递的数据</span><br><span class="line"> </span><br><span class="line">2）堆栈配置好之后，在堆栈开始的位置，为struct global_data预留空间，并将开始地址（就是一个struct global_data指针）</span><br><span class="line">保存在一个寄存器(arm使用r9,arm64使用x18)中，后续的传递，都是通过保存在寄存器中的指针实现</span><br></pre></td></tr></table></figure>

<p>以上摘自：wowo的<a target="_blank" rel="noopener" href="http://www.wowotech.net/u-boot/boot_flow_2.html">u-boot启动流程分析(2)_板级(board)部分</a></p>
<p>gd结构体分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/asm-generic/global_data.h  (u-boot 2018.09)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">global_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">bd_t</span> *bd;              <span class="comment">//传递给kernel的board信息</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;   <span class="comment">//一些标志位，用于指示初始化是否已执行等</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> baudrate; <span class="comment">//串口/console波特率</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cpu_clk; <span class="comment">/* CPU clock in Hz!        */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bus_clk;</span><br><span class="line">    <span class="comment">/* We cannot bracket this with CONFIG_PCI due to mpc5xxx */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pci_clk;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mem_clk;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_LCD) || defined(CONFIG_VIDEO) <span class="comment">//LCD or video相关</span></span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> fb_base;                       <span class="comment">/* Base address of framebuffer mem */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_POST)            <span class="comment">//上电自检相关(Power-On-Self-Test, POST)</span></span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> post_log_word;    <span class="comment">/* Record POST activities */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> post_log_res;     <span class="comment">/* success of POST test */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> post_init_f_time; <span class="comment">/* When post_init_f started */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BOARD_TYPES</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> board_type;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> have_console; <span class="comment">/* serial_init() was called */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在console未初始化前，缓存字符内容，如果定义PRE_CONSOLE_BUFFER</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_IS_ENABLED(PRE_CONSOLE_BUFFER)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> precon_buf_idx; <span class="comment">/* Pre-Console buffer index */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//u-boot环境变量相关</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> env_addr;     <span class="comment">/* Address  of Environment struct */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> env_valid;    <span class="comment">/* Environment valid? enum env_valid */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> env_has_init; <span class="comment">/* Bitmask of boolean of struct env_location offsets */</span></span><br><span class="line">    <span class="type">int</span> env_load_prio;          <span class="comment">/* Priority of the loaded environment */</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ram_base;      <span class="comment">/* Base address of RAM used by U-Boot */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ram_top;       <span class="comment">/* Top address of RAM used by U-Boot */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> relocaddr;     <span class="comment">/* Start address of U-Boot in RAM;u-boot重定向后的地址 */</span></span><br><span class="line">    <span class="type">phys_size_t</span> ram_size;        <span class="comment">/* RAM size */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mon_len;       <span class="comment">/* monitor len，对于arm,等于(ulong)&amp;__bss_end - (ulong)_start*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> irq_sp;        <span class="comment">/* irq stack pointer */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_addr_sp; <span class="comment">/* start_addr_stackpointer */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> reloc_off;     <span class="comment">/* relocate偏移量*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">global_data</span> *<span class="title">new_gd</span>;</span>  <span class="comment">/* relocated global data;重定向后的gd结构体*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//如果启用了驱动模型</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DM</span></span><br><span class="line">    <span class="comment">//DM中的根设备，也是uboot中第一个创建的udevice，也就对应了dts里的根节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">udevice</span> *<span class="title">dm_root</span>;</span> <span class="comment">/* Root instance for Driver Model */</span></span><br><span class="line">    <span class="comment">//在relocation之前DM中的根设备</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">udevice</span> *<span class="title">dm_root_f</span>;</span> <span class="comment">/* Pre-relocation root instance */</span></span><br><span class="line">    <span class="comment">//uclass链表，所有被udevice匹配的uclass都会被挂载到这个链表上</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">uclass_root</span>;</span> <span class="comment">/* Head of core tree */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TIMER</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">udevice</span> *<span class="title">timer</span>;</span> <span class="comment">/* Timer instance for Driver Model */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="type">const</span> <span class="type">void</span> *fdt_blob;   <span class="comment">/* Our device tree, NULL if none; 设备的dtb地址*/</span></span><br><span class="line">    <span class="type">void</span> *new_fdt;          <span class="comment">/* Relocated FDT；重定向后的dtb地址*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> fdt_size; <span class="comment">/* Space reserved for relocated FDT */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_OF_LIVE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_root</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">jt_funcs</span> *<span class="title">jt</span>;</span> <span class="comment">/* jump table */</span></span><br><span class="line">    <span class="type">char</span> env_buf[<span class="number">32</span>];    <span class="comment">/* buffer for env_get() before reloc. */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRACE</span></span><br><span class="line">    <span class="type">void</span> *trace_buff; <span class="comment">/* The trace buffer */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SYS_I2C)</span></span><br><span class="line">    <span class="type">int</span> cur_i2c_bus; <span class="comment">/* current used i2c bus */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYS_I2C_MXC</span></span><br><span class="line">    <span class="type">void</span> *srdata[<span class="number">10</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> timebase_h;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> timebase_l;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_VAL(SYS_MALLOC_F_LEN)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> malloc_base;  <span class="comment">/* base address of early malloc() */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> malloc_limit; <span class="comment">/* limit address */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> malloc_ptr;   <span class="comment">/* current address */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PCI</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pci_controller</span> *<span class="title">hose</span>;</span> <span class="comment">/* PCI hose for early use */</span></span><br><span class="line">    <span class="type">phys_addr_t</span> pci_ram_top;     <span class="comment">/* top of region accessible to PCI */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PCI_BOOTDELAY</span></span><br><span class="line">    <span class="type">int</span> pcidelay_done;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">udevice</span> *<span class="title">cur_serial_dev</span>;</span> <span class="comment">/* current serial device; 当前串口设备号*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arch_global_data</span> <span class="title">arch</span>;</span>   <span class="comment">/* architecture-specific data */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_RECORD</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">membuff</span> <span class="title">console_out</span>;</span> <span class="comment">/* console output */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">membuff</span> <span class="title">console_in</span>;</span>  <span class="comment">/* console input */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DM_VIDEO</span></span><br><span class="line">    ulong video_top;    <span class="comment">/* Top of video frame buffer area */</span></span><br><span class="line">    ulong video_bottom; <span class="comment">/* Bottom of video frame buffer area */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BOOTSTAGE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bootstage_data</span> *<span class="title">bootstage</span>;</span>     <span class="comment">/* Bootstage information */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bootstage_data</span> *<span class="title">new_bootstage</span>;</span> <span class="comment">/* Relocated bootstage info */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOG</span></span><br><span class="line">    <span class="type">int</span> log_drop_count;        <span class="comment">/* Number of dropped log messages */</span></span><br><span class="line">    <span class="type">int</span> default_log_level;     <span class="comment">/* For devices with no filters */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">log_head</span>;</span> <span class="comment">/* List of struct log_device */</span></span><br><span class="line">    <span class="type">int</span> log_fmt;               <span class="comment">/* Mask containing log format info */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="type">gd_t</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Global Data Flags - the top 16 bits are reserved for arch-specific flags</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_FLG_RELOC 0x00001            <span class="comment">/* Code was relocated to RAM          */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_FLG_DEVINIT 0x00002          <span class="comment">/* Devices have been initialized      */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_FLG_SILENT 0x00004           <span class="comment">/* Silent mode                             */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_FLG_POSTFAIL 0x00008         <span class="comment">/* Critical POST test failed          */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_FLG_POSTSTOP 0x00010         <span class="comment">/* POST seqeunce aborted              */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_FLG_LOGINIT 0x00020          <span class="comment">/* Log Buffer has been initialized    */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_FLG_DISABLE_CONSOLE 0x00040  <span class="comment">/* Disable console (in &amp; out)          */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_FLG_ENV_READY 0x00080        <span class="comment">/* Env. imported into hash table      */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_FLG_SERIAL_READY 0x00100     <span class="comment">/* Pre-reloc serial console ready     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_FLG_FULL_MALLOC_INIT 0x00200 <span class="comment">/* Full malloc() is ready              */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_FLG_SPL_INIT 0x00400         <span class="comment">/* spl_init() has been called          */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_FLG_SKIP_RELOC 0x00800       <span class="comment">/* Don&#x27;t relocate                        */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_FLG_RECORD 0x01000           <span class="comment">/* Record console                         */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_FLG_ENV_DEFAULT 0x02000      <span class="comment">/* Default variable flag                 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_FLG_SPL_EARLY_INIT 0x04000   <span class="comment">/* Early SPL init is done              */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_FLG_LOG_READY 0x08000        <span class="comment">/* Log system is ready for use          */</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/asm-generic/u-boot.h (u-boot 2018.09)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Board information passed to Linux kernel from U-Boot</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* include/asm-ppc/u-boot.h</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bd_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bi_memstart;    <span class="comment">/* start of DRAM memory */</span></span><br><span class="line">    <span class="type">phys_size_t</span> bi_memsize;       <span class="comment">/* size     of DRAM memory in bytes */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bi_flashstart;  <span class="comment">/* start of FLASH memory */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bi_flashsize;   <span class="comment">/* size     of FLASH memory */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bi_flashoffset; <span class="comment">/* reserved area for startup monitor */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bi_sramstart;   <span class="comment">/* start of SRAM memory */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bi_sramsize;    <span class="comment">/* size     of SRAM memory */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bi_arm_freq; 		<span class="comment">/* arm frequency */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bi_dsp_freq; 		<span class="comment">/* dsp core frequency */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bi_ddr_freq; 		<span class="comment">/* ddr frequency */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_MPC8xx) || defined(CONFIG_E500) || defined(CONFIG_MPC86xx)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bi_immr_base; 	<span class="comment">/* base of IMMR register */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_M68K)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bi_mbar_base; 	<span class="comment">/* base of internal registers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_MPC83xx)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bi_immrbar;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bi_bootflags;   <span class="comment">/* boot / reboot flag (Unused) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bi_ip_addr;     <span class="comment">/* IP Address */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> bi_enetaddr[<span class="number">6</span>]; <span class="comment">/* OLD: see README.enetaddr */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> bi_ethspeed;   <span class="comment">/* Ethernet speed in Mbps */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bi_intfreq;     <span class="comment">/* Internal Freq, in MHz */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bi_busfreq;     <span class="comment">/* Bus Freq, in MHz */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_CPM2)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bi_cpmfreq; <span class="comment">/* CPM_CLK Freq, in MHz */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bi_brgfreq; <span class="comment">/* BRG_CLK Freq, in MHz */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bi_sccfreq; <span class="comment">/* SCC_CLK Freq, in MHz */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bi_vco;     <span class="comment">/* VCO Out from PLL, in MHz */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_M68K)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bi_ipbfreq; <span class="comment">/* IPB Bus Freq, in MHz */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bi_pcifreq; <span class="comment">/* PCI Bus Freq, in MHz */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_EXTRA_CLOCK)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bi_inpfreq; <span class="comment">/* input Freq in MHz */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bi_vcofreq; <span class="comment">/* vco Freq in MHz */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bi_flbfreq; <span class="comment">/* Flexbus Freq in MHz */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HAS_ETH1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> bi_enet1addr[<span class="number">6</span>]; <span class="comment">/* OLD: see README.enetaddr */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HAS_ETH2</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> bi_enet2addr[<span class="number">6</span>]; <span class="comment">/* OLD: see README.enetaddr */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HAS_ETH3</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> bi_enet3addr[<span class="number">6</span>]; <span class="comment">/* OLD: see README.enetaddr */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HAS_ETH4</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> bi_enet4addr[<span class="number">6</span>]; <span class="comment">/* OLD: see README.enetaddr */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HAS_ETH5</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> bi_enet5addr[<span class="number">6</span>]; <span class="comment">/* OLD: see README.enetaddr */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    ulong bi_arch_number; <span class="comment">/* unique id for this board */</span></span><br><span class="line">    ulong bi_boot_params; <span class="comment">/* where this board expects params */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NR_DRAM_BANKS</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span> <span class="comment">/* RAM configuration */</span></span><br><span class="line">        <span class="type">phys_addr_t</span> start;</span><br><span class="line">        <span class="type">phys_size_t</span> size;</span><br><span class="line">    &#125; bi_dram[CONFIG_NR_DRAM_BANKS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">&#125; <span class="type">bd_t</span>;</span><br></pre></td></tr></table></figure>

<p>对于arm，gd的首地址存放在<code>r9</code>中，u-boot定义了<code>DECLARE_GLOBAL_DATA_PTR</code>宏，通过它即可访问gd结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arch/arm/include/asm/global_data.h</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_GLOBAL_DATA_PTR        register volatile gd_t *gd asm (<span class="string">&quot;x18&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_GLOBAL_DATA_PTR        register volatile gd_t *gd asm (<span class="string">&quot;r9&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>gd的内存分布：</p>
<img src="https://nas.littlekang.xyz:9000/markdown/2022-03/3002_1527-cSG5C1lkWNGWXnM8.png" alt="image-20220330021527690" style="zoom:200%;" />

<p>图来自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ooonebook/article/details/53013545">https://blog.csdn.net/ooonebook/article/details/53013545</a></p>
<h2 id="代码流程"><a href="#代码流程" class="headerlink" title="代码流程"></a>代码流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* 对relocate进行空间规划</span><br><span class="line">* 计算uboot代码空间到relocation的位置的偏移</span><br><span class="line">* relocate旧的global_data到新的global_data的空间上</span><br><span class="line">* relocate旧的uboot代码空间到新的空间上去</span><br><span class="line">* 修改relocate之后全局变量的label。</span><br><span class="line">* relocate中断向量表</span><br></pre></td></tr></table></figure>

<h2 id="基础：ARM-ABI约定"><a href="#基础：ARM-ABI约定" class="headerlink" title="基础：ARM ABI约定"></a>基础：ARM ABI约定</h2><p>ARM架构程序调用标准(Procedure Call Standard for the ARM Architecture, <strong>AAPCS</strong>)描述了ARM架构下应用程序二进制接口(Application Binary Interface, <strong>ABI</strong>)程序调用的标准.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">寄存器      别名        特殊名          程序调用标准中作用</span><br><span class="line">r15                     PC              程序计数器.</span><br><span class="line">r14                     LR              链接寄存器.</span><br><span class="line">r13                     SP              栈指针.</span><br><span class="line">r12                     IP              程序调用过程中备份寄存器.</span><br><span class="line">r11         v8                          变量寄存器8.</span><br><span class="line">r10         v7                          变量寄存器7.</span><br><span class="line">r9                      v6 / SB / TR    平台寄存器, 该寄存器意义由平台标准指定.</span><br><span class="line">r8          v5                          变量寄存器5.</span><br><span class="line">r7          v4                          变量寄存器4.</span><br><span class="line">r6          v3                          变量寄存器3.</span><br><span class="line">r5          v2                          变量寄存器2.</span><br><span class="line">r4          v1                          变量寄存器1.</span><br><span class="line">r3          a4                          参数 / 备份寄存器4.</span><br><span class="line">r2          a3                          参数 / 备份寄存器3.</span><br><span class="line">r1          a2                          参数 / 结果 / 备份寄存器2.</span><br><span class="line">r0          a1                          参数 / 结果 / 备份寄存器1.</span><br></pre></td></tr></table></figure>

<p><strong>程序计数器r15–PC</strong>——指向<code>正在取址</code>的指令</p>
<p>由于RAM的流水线结构，对于3级流水线结构，指令分为三个阶段执行：取址，译码(识别将要被执行的指令)，执行(处理指令并将结果写回寄存器)；<strong>人们习惯约定将“正在执行的指令作为参考点”</strong>，称之为当前第一条指令，因此PC总是指向第3条指令，对于arm32，每条指令为4byte，所以**<code>PC=当前程序执行位置+8</code>**.</p>
<p><strong>链接寄存器r14–LR</strong>——用于保存子程序的返回地址;</p>
<p><strong>栈指针r13–SP</strong>——指示当前要出栈或入栈的数据</p>
<p>在子程序中寄存器r13不能用作它用，它的值在进入、退出子程序时必须相等;</p>
<h2 id="总体代码-main"><a href="#总体代码-main" class="headerlink" title="总体代码-_main"></a>总体代码-<code>_main</code></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">#arch/arm/lib/crt0.S</span><br><span class="line"> </span><br><span class="line">ENTRY(_main)</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line">* Set up initial C runtime environment and call board_init_f(0).</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">    #预设堆栈指针，只是预设的堆栈地址，不是最终的</span><br><span class="line">#if defined(CONFIG_SPL_BUILD) &amp;&amp; defined(CONFIG_SPL_STACK)</span><br><span class="line">    ldr    r0, =(CONFIG_SPL_STACK)            #SPL的话一般使用片内SRAM</span><br><span class="line">#else</span><br><span class="line">    ldr    r0, =(CONFIG_SYS_INIT_SP_ADDR)    #u-boot使用片外SDRAM</span><br><span class="line">#endif</span><br><span class="line">    bic    r0, r0, #7    /* 8-byte alignment for ABI compliance */</span><br><span class="line"> </span><br><span class="line">    /*</span><br><span class="line">    * 将r0作为board_init_f_alloc_reserve()的参数，分配栈空间</span><br><span class="line">    * 返回后，r0里存放的是gd的首地址，同时也是新的堆栈地址</span><br><span class="line">    * 因为堆栈是向下增长的，而gd的内容是向上的，所以互不冲突</span><br><span class="line">    */</span><br><span class="line">    mov    sp, r0</span><br><span class="line">    bl    board_init_f_alloc_reserve</span><br><span class="line">    mov    sp, r0</span><br><span class="line">    /* set up gd here, outside any C code */</span><br><span class="line">    mov    r9, r0     #使用r9保存gd的首地址</span><br><span class="line"> </span><br><span class="line">    #初始化gd结构体</span><br><span class="line">    bl    board_init_f_init_reserve</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    /*</span><br><span class="line">    * board_init_f实现了：</span><br><span class="line">    *        1.对relocate进行空间规划</span><br><span class="line">    *        2.计算uboot代码空间到relocation的位置的偏移</span><br><span class="line">    *        3.relocate旧的global_data到新的global_data的空间上</span><br><span class="line">    */</span><br><span class="line">    mov    r0, #0</span><br><span class="line">    bl    board_init_f</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#if ! defined(CONFIG_SPL_BUILD)</span><br><span class="line">/*</span><br><span class="line">* Set up intermediate environment (new sp and gd) and call</span><br><span class="line">* relocate_code(addr_moni). Trick here is that we&#x27;ll return</span><br><span class="line">* &#x27;here&#x27; but relocated.</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">    #新的栈地址</span><br><span class="line">    ldr    r0, [r9, #GD_START_ADDR_SP]    /* sp = gd-&gt;start_addr_sp */</span><br><span class="line">    bic    r0, r0, #7                    /* 8-byte alignment for ABI compliance */</span><br><span class="line">    mov    sp, r0                       </span><br><span class="line"> </span><br><span class="line">    #新的gd地址，新gd位于旧gd-&gt;bd之下</span><br><span class="line">    ldr    r9, [r9, #GD_BD]            /* r9 = gd-&gt;bd */</span><br><span class="line">    sub    r9, r9, #GD_SIZE            /* new GD is below bd */</span><br><span class="line"> </span><br><span class="line">    #计算返回地址在新的u-boot空间中的地址。b调用函数返回之后，就跳到了新的u-boot代码空间中</span><br><span class="line">    adr    lr, here</span><br><span class="line">    ldr    r0, [r9, #GD_RELOC_OFF]        /* r0 = gd-&gt;reloc_off */</span><br><span class="line">    add    lr, lr, r0</span><br><span class="line">    #if defined(CONFIG_CPU_V7M)</span><br><span class="line">        orr    lr, #1                    /* As required by Thumb-only */</span><br><span class="line">    #endif</span><br><span class="line">    ldr    r0, [r9, #GD_RELOCADDR]        /* r0 = gd-&gt;relocaddr */</span><br><span class="line"> </span><br><span class="line">    /* relocate_code实现了</span><br><span class="line">    * 1. relocate旧的uboot代码空间到新的空间上去</span><br><span class="line">    * 2. 修改relocate之后全局变量的label(.rel.dyn段等)</span><br><span class="line">    */</span><br><span class="line">    b    relocate_code</span><br><span class="line"> </span><br><span class="line">    #以下为新的u-boot代码空间</span><br><span class="line"> </span><br><span class="line">here:</span><br><span class="line">    /*</span><br><span class="line">    * now relocate vectors</span><br><span class="line">    */</span><br><span class="line">    bl    relocate_vectors</span><br><span class="line"> </span><br><span class="line">/* Set up final (full) environment */</span><br><span class="line"> </span><br><span class="line">    bl    c_runtime_cpu_setup    /* we still call old routine here */</span><br><span class="line">#endif /*!defined(CONFIG_SPL_BUILD)*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_FRAMEWORK)</span><br><span class="line">    #对于SPL</span><br><span class="line">    #ifdef CONFIG_SPL_BUILD</span><br><span class="line">        /* Use a DRAM stack for the rest of SPL, if requested */</span><br><span class="line">        bl    spl_relocate_stack_gd</span><br><span class="line">        cmp    r0, #0</span><br><span class="line">        movne    sp, r0</span><br><span class="line">        movne    r9, r0</span><br><span class="line">    #endif</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    /*</span><br><span class="line">    * 以下作用：清空bss段</span><br><span class="line">    */</span><br><span class="line">    ldr    r0, =__bss_start    /* this is auto-relocated! */</span><br><span class="line">    #ifdef CONFIG_USE_ARCH_MEMSET</span><br><span class="line">        ldr    r3, =__bss_end        /* this is auto-relocated! */</span><br><span class="line">        mov    r1, #0x00000000        /* prepare zero to clear BSS */</span><br><span class="line"> </span><br><span class="line">        subs    r2, r3, r0        /* r2 = memset len */</span><br><span class="line">        bl    memset</span><br><span class="line">    #else</span><br><span class="line">        ldr    r1, =__bss_end        /* this is auto-relocated! */</span><br><span class="line">        mov    r2, #0x00000000        /* prepare zero to clear BSS */</span><br><span class="line"> </span><br><span class="line">        clbss_l:cmp    r0, r1            /* while not at end of BSS */</span><br><span class="line">        #if defined(CONFIG_CPU_V7M)</span><br><span class="line">            itt    lo</span><br><span class="line">        #endif</span><br><span class="line">        strlo    r2, [r0]        /* clear 32-bit BSS word */</span><br><span class="line">        addlo    r0, r0, #4        /* move to next */</span><br><span class="line">        blo    clbss_l</span><br><span class="line">    #endif</span><br><span class="line"> </span><br><span class="line">    #if ! defined(CONFIG_SPL_BUILD)</span><br><span class="line">        bl coloured_LED_init</span><br><span class="line">        bl red_led_on</span><br><span class="line">    #endif</span><br><span class="line"> </span><br><span class="line">    /*</span><br><span class="line">    * 执行board_init_r()</span><br><span class="line">    * 参数1： gd-&gt;new_gd</span><br><span class="line">    * 参数2： gd-&gt;relocaddr</span><br><span class="line">    */</span><br><span class="line">    /* call board_init_r(gd_t *id, ulong dest_addr) */</span><br><span class="line">    mov     r0, r9                  /* gd_t */</span><br><span class="line">    ldr    r1, [r9, #GD_RELOCADDR]        /* dest_addr */</span><br><span class="line"> </span><br><span class="line">    /* call board_init_r */</span><br><span class="line">    #if CONFIG_IS_ENABLED(SYS_THUMB_BUILD)</span><br><span class="line">        ldr    lr, =board_init_r        /* this is auto-relocated! */</span><br><span class="line">        bx    lr</span><br><span class="line">    #else</span><br><span class="line">        ldr    pc, =board_init_r        /* this is auto-relocated! */</span><br><span class="line"> </span><br><span class="line">        @ mov r0, #0xfd</span><br><span class="line">        @ bl    asm_led_on</span><br><span class="line">    #endif</span><br><span class="line"> </span><br><span class="line">    /* we should not return here. */</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">ENDPROC(_main)</span><br></pre></td></tr></table></figure>

<p><strong>以下内容，以正在移植的OK6410板子为分析对象。</strong></p>
<h2 id="board-init-f-alloc-reserve-分析"><a href="#board-init-f-alloc-reserve-分析" class="headerlink" title="board_init_f_alloc_reserve()分析"></a>board_init_f_alloc_reserve()分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//common/init/board_init.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Allocate reserved space for use as &#x27;globals&#x27; from &#x27;top&#x27; address and</span></span><br><span class="line"><span class="comment">* return &#x27;bottom&#x27; address of allocated space</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Notes:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Actual reservation cannot be done from within this function as</span></span><br><span class="line"><span class="comment">* it requires altering the C stack pointer, so this will be done by</span></span><br><span class="line"><span class="comment">* the caller upon return from this function.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* IMPORTANT:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Alignment constraints may differ for each &#x27;chunk&#x27; allocated. For now:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* - GD is aligned down on a 16-byte boundary</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"> *  - the early malloc arena is not aligned, therefore it follows the stack</span></span><br><span class="line"><span class="comment"> *   alignment constraint of the architecture for which we are bulding.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"> *  - GD is allocated last, so that the return value of this functions is</span></span><br><span class="line"><span class="comment"> *   both the bottom of the reserved area and the address of GD, should</span></span><br><span class="line"><span class="comment"> *   the calling context need it.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 以手头的OK6410板子分析：</span></span><br><span class="line"><span class="comment">* CONFIG_SYS_TEXT_BASE = 0x5FE00000</span></span><br><span class="line"><span class="comment">* CONFIG_SYS_INIT_SP_ADDR = (CONFIG_SYS_TEXT_BASE - 0x80)</span></span><br><span class="line"><span class="comment">* SYS_MALLOC_F_LEN宏没有定义</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">ulong <span class="title function_">board_init_f_alloc_reserve</span><span class="params">(ulong top)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Reserve early malloc arena */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_VAL(SYS_MALLOC_F_LEN)</span></span><br><span class="line">    top -= CONFIG_VAL(SYS_MALLOC_F_LEN);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* LAST : reserve GD (rounded up to a multiple of 16 bytes) */</span></span><br><span class="line">    <span class="comment">//保留出了用于存放gd的空间，并使新sp地址16字节对齐，这里gd_size=208=0xd0</span></span><br><span class="line">    top = rounddown(top-<span class="keyword">sizeof</span>(<span class="keyword">struct</span> global_data), <span class="number">16</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="board-init-f-init-reserve分析"><a href="#board-init-f-init-reserve分析" class="headerlink" title="board_init_f_init_reserve分析"></a>board_init_f_init_reserve分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//common/init/board_init.c</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Initialize reserved space (which has been safely allocated on the C</span></span><br><span class="line"><span class="comment">* stack from the C runtime environment handling code).</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Notes:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Actual reservation was done by the caller; the locations from base</span></span><br><span class="line"><span class="comment">* to base+size-1 (where &#x27;size&#x27; is the value returned by the allocation</span></span><br><span class="line"><span class="comment">* function above) can be accessed freely without risk of corrupting the</span></span><br><span class="line"><span class="comment">* C runtime environment.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* IMPORTANT:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Upon return from the allocation function above, on some architectures</span></span><br><span class="line"><span class="comment">* the caller will set gd to the lowest reserved location. Therefore, in</span></span><br><span class="line"><span class="comment">* this initialization function, the global data MUST be placed at base.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* ALSO IMPORTANT:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* On some architectures, gd will already be good when entering this</span></span><br><span class="line"><span class="comment">* function. On others, it will only be good once arch_setup_gd() returns.</span></span><br><span class="line"><span class="comment">* Therefore, global data accesses must be done:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* - through gd_ptr if before the call to arch_setup_gd();</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* - through gd once arch_setup_gd() has been called.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Do not use &#x27;gd-&gt;&#x27; until arch_setup_gd() has been called!</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* IMPORTANT TOO:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Initialization for each &quot;chunk&quot; (GD, early malloc arena...) ends with</span></span><br><span class="line"><span class="comment">* an incrementation line of the form &#x27;base += &lt;some size&gt;&#x27;. The last of</span></span><br><span class="line"><span class="comment">* these incrementations seems useless, as base will not be used any</span></span><br><span class="line"><span class="comment">* more after this incrementation; but if/when a new &quot;chunk&quot; is appended,</span></span><br><span class="line"><span class="comment">* this increment will be essential as it will give base right value for</span></span><br><span class="line"><span class="comment">* this new chunk (which will have to end with its own incrementation</span></span><br><span class="line"><span class="comment">* statement). Besides, the compiler&#x27;s optimizer will silently detect</span></span><br><span class="line"><span class="comment">* and remove the last base incrementation, therefore leaving that last</span></span><br><span class="line"><span class="comment">* (seemingly useless) incrementation causes no code increase.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">board_init_f_init_reserve</span><span class="params">(ulong base)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">global_data</span> *<span class="title">gd_ptr</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * clear GD entirely and set it up.</span></span><br><span class="line"><span class="comment">     * Use gd_ptr, as gd may not be properly set yet.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    gd_ptr = (<span class="keyword">struct</span> global_data *)base;</span><br><span class="line">    <span class="comment">/* zero the area */</span></span><br><span class="line">    <span class="built_in">memset</span>(gd_ptr, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(*gd));</span><br><span class="line">    <span class="comment">/* set GD unless architecture did it already */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(CONFIG_ARM)</span></span><br><span class="line">    arch_setup_gd(gd_ptr);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* next alloc will be higher by one GD plus 16-byte alignment */</span></span><br><span class="line">    base += roundup(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> global_data), <span class="number">16</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * record early malloc arena start.</span></span><br><span class="line"><span class="comment">     * Use gd as it is now properly set for all architectures.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_VAL(SYS_MALLOC_F_LEN)</span></span><br><span class="line">    <span class="comment">/* go down one &#x27;early malloc arena&#x27; */</span></span><br><span class="line">    gd-&gt;malloc_base = base;</span><br><span class="line">    <span class="comment">/* next alloc will be higher by one &#x27;early malloc arena&#x27; size */</span></span><br><span class="line">    base += CONFIG_VAL(SYS_MALLOC_F_LEN);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完此函数后，内存分布如下：</p>
<img src="https://nas.littlekang.xyz:9000/markdown/2022-03/3100_4910-n6OxP0RAMVr3HlBF.png" alt="image-20220331004909952" style="zoom:200%;" />

 

<h2 id="board-init-f-分析"><a href="#board-init-f-分析" class="headerlink" title="board_init_f()分析"></a>board_init_f()分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//common/board_f.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">board_init_f</span><span class="params">(ulong boot_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//通过r9访问gd结构体</span></span><br><span class="line">    gd-&gt;flags = boot_flags;</span><br><span class="line">    gd-&gt;have_console = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//通过init_sequence_f指针数组执行初始化流程，指针数组中存放各初始化函数首地址   </span></span><br><span class="line">    <span class="keyword">if</span> (initcall_run_list(init_sequence_f))</span><br><span class="line">        hang();</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(CONFIG_ARM) &amp;&amp; !defined(CONFIG_SANDBOX) &amp;&amp; \</span></span><br><span class="line"><span class="meta">        !defined(CONFIG_EFI_APP) &amp;&amp; !CONFIG_IS_ENABLED(X86_64) &amp;&amp; \</span></span><br><span class="line"><span class="meta">        !defined(CONFIG_ARC)</span></span><br><span class="line">    <span class="comment">/* NOTREACHED - jump_to_copy() does not return */</span></span><br><span class="line">    hang();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//init_sequence_f数组</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">init_fnc_t</span> init_sequence_f[] = &#123;</span><br><span class="line">    setup_mon_len,      <span class="comment">//设置gd-&gt;mon_len,即u-boot的大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_OF_CONTROL</span></span><br><span class="line">    fdtdec_setup,        <span class="comment">//设置gd-&gt;fdt_blob,即dts存放的地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRACE</span></span><br><span class="line">    trace_early_init,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">   dram_init,			<span class="comment">/* configure available RAM banks */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略..... 删除部分宏相关，对arm平台无效代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下是一些和布局相关得函数</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now that we have DRAM mapped and working, we can</span></span><br><span class="line"><span class="comment">     * relocate the code and continue running from DRAM.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Reserve memory at end of RAM for (top down in that order):</span></span><br><span class="line"><span class="comment">     *  - area that won&#x27;t get touched by U-Boot and Linux (optional)</span></span><br><span class="line"><span class="comment">     *  - kernel log buffer</span></span><br><span class="line"><span class="comment">     *  - protected RAM</span></span><br><span class="line"><span class="comment">     *  - LCD framebuffer</span></span><br><span class="line"><span class="comment">     *  - monitor code</span></span><br><span class="line"><span class="comment">     *  - board info struct</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    setup_dest_addr,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PRAM</span></span><br><span class="line">    reserve_pram,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    reserve_round_4k,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM</span></span><br><span class="line">    reserve_mmu,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    reserve_video,</span><br><span class="line">    reserve_trace,</span><br><span class="line">    reserve_uboot,</span><br><span class="line">    reserve_malloc,</span><br><span class="line">    reserve_board,</span><br><span class="line">    setup_machine,</span><br><span class="line">    reserve_global_data,</span><br><span class="line">    reserve_fdt,</span><br><span class="line">    reserve_bootstage,</span><br><span class="line">    reserve_arch,</span><br><span class="line">    reserve_stacks,</span><br><span class="line">    dram_init_banksize,</span><br><span class="line">    show_dram_config,</span><br><span class="line">    display_new_sp,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_OF_BOARD_FIXUP</span></span><br><span class="line">    fix_fdt,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">    reloc_fdt,</span><br><span class="line">    reloc_bootstage,</span><br><span class="line">    setup_reloc,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(CONFIG_ARM) &amp;&amp; !defined(CONFIG_SANDBOX) &amp;&amp; \</span></span><br><span class="line"><span class="meta">        !CONFIG_IS_ENABLED(X86_64)</span></span><br><span class="line">    jump_to_copy,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里分析一些重要的函数：</p>
<ul>
<li><p><strong>setup_dest_addr()</strong>–目的地址初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//common/board_f.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">setup_dest_addr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*表示u-boot的大小，在uboot代码空间relocate的时候，</span></span><br><span class="line"><span class="comment">    * relocate的size就是由这里决定</span></span><br><span class="line"><span class="comment">    * gd-&gt;mon_len = (ulong)&amp;__bss_end - (ulong)_start;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	debug(<span class="string">&quot;Monitor len: %08lX\n&quot;</span>, gd-&gt;mon_len);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ram is setup, size stored in gd !!</span></span><br><span class="line"><span class="comment">	 * 表示ram的大小，对于ok6410，在smdk6410.c中由dram_init()初始化</span></span><br><span class="line"><span class="comment">	 * 	gd-&gt;bd-&gt;bi_dram[0].start = 0x50000000; </span></span><br><span class="line"><span class="comment">     *	gd-&gt;bd-&gt;bi_dram[0].size = 0x10000000; //256M</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	debug(<span class="string">&quot;Ram size: %08lX\n&quot;</span>, (ulong)gd-&gt;ram_size);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SYS_MEM_TOP_HIDE)</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Subtract specified amount of memory to hide so that it won&#x27;t</span></span><br><span class="line"><span class="comment">	 * get &quot;touched&quot; at all by U-Boot. By fixing up gd-&gt;ram_size</span></span><br><span class="line"><span class="comment">	 * the Linux kernel should now get passed the now &quot;corrected&quot;</span></span><br><span class="line"><span class="comment">	 * memory size and won&#x27;t touch it either. This should work</span></span><br><span class="line"><span class="comment">	 * for arch/ppc and arch/powerpc. Only Linux board ports in</span></span><br><span class="line"><span class="comment">	 * arch/powerpc with bootwrapper support, that recalculate the</span></span><br><span class="line"><span class="comment">	 * memory size from the SDRAM controller setup will have to</span></span><br><span class="line"><span class="comment">	 * get fixed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	gd-&gt;ram_size -= CONFIG_SYS_MEM_TOP_HIDE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYS_SDRAM_BASE</span></span><br><span class="line">	gd-&gt;ram_base = CONFIG_SYS_SDRAM_BASE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 计算dram的顶端地址：gd-&gt;ram_top = gd-&gt;ram_base + gd-&gt;ram_size;</span></span><br><span class="line"><span class="comment">    * relocate地址(新u-boot的起始地址)：gd-&gt;relocaddr = gd-&gt;ram_top;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	gd-&gt;ram_top = gd-&gt;ram_base + get_effective_memsize();</span><br><span class="line">	gd-&gt;ram_top = board_get_usable_ram_top(gd-&gt;mon_len);</span><br><span class="line">	gd-&gt;relocaddr = gd-&gt;ram_top;</span><br><span class="line">	debug(<span class="string">&quot;Ram top: %08lX\n&quot;</span>, (ulong)gd-&gt;ram_top);</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_MP) &amp;&amp; (defined(CONFIG_MPC86xx) || defined(CONFIG_E500))</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We need to make sure the location we intend to put secondary core</span></span><br><span class="line"><span class="comment">	 * boot code is reserved and not used by any part of u-boot</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (gd-&gt;relocaddr &gt; determine_mp_bootpg(<span class="literal">NULL</span>)) &#123;</span><br><span class="line">		gd-&gt;relocaddr = determine_mp_bootpg(<span class="literal">NULL</span>);</span><br><span class="line">		debug(<span class="string">&quot;Reserving MP boot page to %08lx\n&quot;</span>, gd-&gt;relocaddr);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>setup_reloc()</strong>–计算u-boot地址偏移量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//common/board_f.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">setup_reloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (gd-&gt;flags &amp; GD_FLG_SKIP_RELOC) &#123;</span><br><span class="line">		debug(<span class="string">&quot;Skipping relocation due to flag\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYS_TEXT_BASE</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ARM</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 对于arm</span></span><br><span class="line"><span class="comment">    * 偏移量gd-&gt;reloc_off=gd-&gt;relocaddr-(unsigned long)__image_copy_start</span></span><br><span class="line"><span class="comment">    * gd-&gt;relocaddr为新u-boot的起始地址</span></span><br><span class="line"><span class="comment">    * __image_copy_start在u-boot.lds链接器脚本文件中定义，是旧u-boot的起始地址</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	gd-&gt;reloc_off = gd-&gt;relocaddr - (<span class="type">unsigned</span> <span class="type">long</span>)__image_copy_start;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_M68K)</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On all ColdFire arch cpu, monitor code starts always</span></span><br><span class="line"><span class="comment">	 * just after the default vector table location, so at 0x400</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	gd-&gt;reloc_off = gd-&gt;relocaddr - (CONFIG_SYS_TEXT_BASE + <span class="number">0x400</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	gd-&gt;reloc_off = gd-&gt;relocaddr - CONFIG_SYS_TEXT_BASE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">//relocate旧的global_data到新的global_data的空间上</span></span><br><span class="line">	<span class="built_in">memcpy</span>(gd-&gt;new_gd, (<span class="type">char</span> *)gd, <span class="keyword">sizeof</span>(<span class="type">gd_t</span>));</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">&quot;Relocation Offset is: %08lx\n&quot;</span>, gd-&gt;reloc_off);</span><br><span class="line">	debug(<span class="string">&quot;Relocating to %08lx, new gd at %08lx, sp at %08lx\n&quot;</span>,</span><br><span class="line">	      gd-&gt;relocaddr, (ulong)map_to_sysmem(gd-&gt;new_gd),</span><br><span class="line">	      gd-&gt;start_addr_sp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="relocate-code分析"><a href="#relocate-code分析" class="headerlink" title="relocate_code分析"></a>relocate_code分析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#ldr    r0, [r9, #GD_RELOCADDR]</span><br><span class="line">#bl relocate_code</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * arch/arm/lib/relocate.S</span><br><span class="line"> *</span><br><span class="line"> * void relocate_code(addr_moni)</span><br><span class="line"> *</span><br><span class="line"> * This function relocates the monitor code.</span><br><span class="line"> *</span><br><span class="line"> * NOTE:</span><br><span class="line"> * To prevent the code below from containing references with an R_ARM_ABS32</span><br><span class="line"> * relocation record type, we never refer to linker-defined symbols directly.</span><br><span class="line"> * Instead, we declare literals which contain their relative location with</span><br><span class="line"> * respect to relocate_code, and at run time, add relocate_code back to them.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">ENTRY(relocate_code)</span><br><span class="line">	/*</span><br><span class="line">	* r0是新的u-boot起始地址， __image_copy_start是原u-boot起始地址</span><br><span class="line">	* r4偏移量， r2原u-boot的结束地址  </span><br><span class="line">	*/</span><br><span class="line">	ldr	r1, =__image_copy_start	/* r1 &lt;- SRC &amp;__image_copy_start */</span><br><span class="line">	subs	r4, r0, r1			/* r4 &lt;- relocation offset */</span><br><span class="line">	beq	relocate_done			/* skip relocation */</span><br><span class="line">	ldr	r2, =__image_copy_end	/* r2 &lt;- SRC &amp;__image_copy_end */</span><br><span class="line"></span><br><span class="line">copy_loop:</span><br><span class="line">	ldmia	r1!, &#123;r10-r11&#125;		/* copy from source address [r1]    */</span><br><span class="line">	stmia	r0!, &#123;r10-r11&#125;		/* copy to   target address [r0]    */</span><br><span class="line">	cmp	r1, r2					/* until source end address [r2]    */</span><br><span class="line">	blo	copy_loop</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * relocate之后，根据位置无关代码原理，需要fix.rel .dyn段的地址</span><br><span class="line">	 * fix .rel.dyn relocations</span><br><span class="line">	 */</span><br><span class="line">	ldr	r2, =__rel_dyn_start	/* r2 &lt;- SRC &amp;__rel_dyn_start */</span><br><span class="line">	ldr	r3, =__rel_dyn_end		/* r3 &lt;- SRC &amp;__rel_dyn_end */</span><br><span class="line">fixloop:</span><br><span class="line">	ldmia	r2!, &#123;r0-r1&#125;		/* (r0,r1) &lt;- (SRC location,fixup) */</span><br><span class="line">	and	r1, r1, #0xff</span><br><span class="line">	cmp	r1, #R_ARM_RELATIVE		/*R_ARM_RELATIVE=23=0x17*/</span><br><span class="line">	bne	fixnext					/*比较高4byte是否是0x17,不是说明不是label*/</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	* label在relocate uboot的时候也已经复制到了新的uboot地址空间了</span><br><span class="line">	* 这里要注意，是对新的uboot地址空间label进行修改</span><br><span class="line">	*/</span><br><span class="line">	</span><br><span class="line">	/* relative fix: increase location by offset */</span><br><span class="line">	/*</span><br><span class="line">	* r0存的是旧地址空间的label地址</span><br><span class="line">	* 新地址空间的label地址=旧地址空间的label地址+偏移</span><br><span class="line">	*/</span><br><span class="line">	add	r0, r0, r4</span><br><span class="line">	ldr	r1, [r0]			/*从label中获取绝对地址符号的地址，存放在r1中*/	</span><br><span class="line">	add	r1, r1, r4			/*新地址*/</span><br><span class="line">	str	r1, [r0]			/*更新label地址*/</span><br><span class="line">fixnext:</span><br><span class="line">	cmp	r2, r3</span><br><span class="line">	blo	fixloop</span><br><span class="line"></span><br><span class="line">relocate_done:</span><br><span class="line"></span><br><span class="line">#ifdef __XSCALE__</span><br><span class="line">	/*</span><br><span class="line">	 * On xscale, icache must be invalidated and write buffers drained,</span><br><span class="line">	 * even with cache disabled - 4.2.7 of xscale core developer&#x27;s manual</span><br><span class="line">	 */</span><br><span class="line">	mcr	p15, 0, r0, c7, c7, 0	/* invalidate icache */</span><br><span class="line">	mcr	p15, 0, r0, c7, c10, 4	/* drain write buffer */</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	/* ARMv4- don&#x27;t know bx lr but the assembler fails to see that */</span><br><span class="line"></span><br><span class="line">#ifdef __ARM_ARCH_4__</span><br><span class="line">	mov	pc, lr</span><br><span class="line">#else</span><br><span class="line">	bx	lr</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">ENDPROC(relocate_code)</span><br></pre></td></tr></table></figure>



<h2 id="relocate-vectors分析"><a href="#relocate-vectors分析" class="headerlink" title="relocate_vectors分析"></a>relocate_vectors分析</h2><p>arm平台中断向量表定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#arch/arm/lib/vectors.S</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *************************************************************************</span><br><span class="line"> *</span><br><span class="line"> * Indirect vectors table</span><br><span class="line"> *</span><br><span class="line"> * Symbols referenced here must be defined somewhere else</span><br><span class="line"> *</span><br><span class="line"> *************************************************************************</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">	.globl	_undefined_instruction</span><br><span class="line">	.globl	_software_interrupt</span><br><span class="line">	.globl	_prefetch_abort</span><br><span class="line">	.globl	_data_abort</span><br><span class="line">	.globl	_not_used</span><br><span class="line">	.globl	_irq</span><br><span class="line">	.globl	_fiq</span><br><span class="line"></span><br><span class="line">_undefined_instruction:	.word undefined_instruction</span><br><span class="line">_software_interrupt:	.word software_interrupt</span><br><span class="line">_prefetch_abort:	.word prefetch_abort</span><br><span class="line">_data_abort:		.word data_abort</span><br><span class="line">_not_used:		.word not_used</span><br><span class="line">_irq:			.word irq</span><br><span class="line">_fiq:			.word fiq</span><br><span class="line"></span><br><span class="line">	.balignl 16,0xdeadbeef</span><br></pre></td></tr></table></figure>

<p>在ARM V4及V4T以后的大部分处理器中，<strong>中断向量表的位置可以有两个位置</strong>：一个是<code>0x00000000</code>，另一个是<code>0xFFFF0000</code>。可以通过CP15协处理器c1寄存器中V位(bit[13])控制。V和中断向量表的对应关系如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">V=0  0x00000000~0x0000001C</span><br><span class="line"></span><br><span class="line">V=1  0xFFFF0000~0xFFFF001C</span><br></pre></td></tr></table></figure>

<p>当u-boot relocate之后，其异常处理函数也发生了变化，所以需要更新中断向量表。</p>
<p>查看objdump反汇编的u-boot文件，可以知道中断向量表在u-boot代码空间的情况：</p>
<img src="https://nas.littlekang.xyz:9000/markdown/2022-04/0102_1720-T2pkc1yHyW9n6wiB.png" alt="image-20220401021720267" style="zoom:200%;" />

<p>relocate_vectors代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#arch/arm/lib/relocate.S</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Default/weak exception vectors relocation routine</span><br><span class="line"> *</span><br><span class="line"> * This routine covers the standard ARM cases: normal (0x00000000),</span><br><span class="line"> * high (0xffff0000) and VBAR. SoCs which do not comply with any of</span><br><span class="line"> * the standard cases must provide their own, strong, version.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">	.section	.text.relocate_vectors,&quot;ax&quot;,%progbits</span><br><span class="line">	.weak		relocate_vectors</span><br><span class="line"></span><br><span class="line">ENTRY(relocate_vectors)</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_CPU_V7M</span><br><span class="line">	/*</span><br><span class="line">	 * On ARMv7-M we only have to write the new vector address</span><br><span class="line">	 * to VTOR register.</span><br><span class="line">	 */</span><br><span class="line">	ldr	r0, [r9, #GD_RELOCADDR]	/* r0 = gd-&gt;relocaddr */</span><br><span class="line">	ldr	r1, =V7M_SCB_BASE</span><br><span class="line">	str	r0, [r1, V7M_SCB_VTOR]</span><br><span class="line">#else</span><br><span class="line">#ifdef CONFIG_HAS_VBAR</span><br><span class="line">	/*</span><br><span class="line">	 * If the ARM processor has the security extensions,</span><br><span class="line">	 * use VBAR to relocate the exception vectors.</span><br><span class="line">	 */</span><br><span class="line">	ldr	r0, [r9, #GD_RELOCADDR]	/* r0 = gd-&gt;relocaddr */</span><br><span class="line">	mcr     p15, 0, r0, c12, c0, 0  /* Set VBAR */</span><br><span class="line">#else</span><br><span class="line">	/*</span><br><span class="line">	 * Copy the relocated exception vectors to the</span><br><span class="line">	 * correct address</span><br><span class="line">	 * CP15 c1 V bit gives us the location of the vectors:</span><br><span class="line">	 * 0x00000000 or 0xFFFF0000.</span><br><span class="line">	 * cp15协处理器的c1寄存器v标志位来决定向量表位置：0x00000000 or 0xFFFF0000</span><br><span class="line">	 */</span><br><span class="line">	ldr	r0, [r9, #GD_RELOCADDR]	/* r0 = gd-&gt;relocaddr，获取新u-boot起始地址*/</span><br><span class="line">	</span><br><span class="line">	mrc	p15, 0, r2, c1, c0, 0	/* V bit (bit[13]) in CP15 c1 */</span><br><span class="line">	ands	r2, r2, #(1 &lt;&lt; 13)</span><br><span class="line">	ldreq	r1, =0x00000000		/* If V=0 */</span><br><span class="line">	ldrne	r1, =0xFFFF0000		/* If V=1 */</span><br><span class="line">	</span><br><span class="line">	/*</span><br><span class="line">	* 没明白？？？？</span><br><span class="line">	*/</span><br><span class="line">	ldmia	r0!, &#123;r2-r8,r10&#125;</span><br><span class="line">	stmia	r1!, &#123;r2-r8,r10&#125;</span><br><span class="line">	ldmia	r0!, &#123;r2-r8,r10&#125;</span><br><span class="line">	stmia	r1!, &#123;r2-r8,r10&#125;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">	bx	lr</span><br><span class="line"></span><br><span class="line">ENDPROC(relocate_vectors)</span><br></pre></td></tr></table></figure>



<h1 id="待处理问题"><a href="#待处理问题" class="headerlink" title="待处理问题"></a>待处理问题</h1><p>u-boot relocate后的内存布局？</p>
<h1 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ooonebook/article/details/53047992">uboot番外篇–uboot relocation介绍</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/skyflying2012/article/details/37660265">uboot的ocation原理详细分析</a></p>
<p><a target="_blank" rel="noopener" href="https://wowothink.com/146db8db/">u-boot启动流程</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cfanz.cn/resource/detail/jWPXyMJJxDBYM">超详细【Uboot驱动开发】(二) uboot启动流程分析</a></p>
</blockquote>
</div><div class="tags"><a href="/tags/u-boot/"><i class="fa fa-tag"></i>u-boot</a></div><div class="post-nav"><a class="next" href="/article/3481/">使用acme.sh申请泛域名证书</a></div><script src="https://utteranc.es/client.js" repo="echomlv/blog_comments" issue-term="title" theme="github-light" crossorigin="anonymous" async> </script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa fa-blind"> Contents </i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#rerocate%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">rerocate介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#relocate%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.</span> <span class="toc-text">relocate是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81relocate"><span class="toc-number">1.2.</span> <span class="toc-text">为什么需要relocate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPL%E5%92%8Crelocate%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.</span> <span class="toc-text">SPL和relocate的关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#relocate%E5%AE%9E%E7%8E%B0%E9%9C%80%E8%A6%81%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.</span> <span class="toc-text">relocate实现需要的条件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">需要的条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE%E6%97%A0%E5%85%B3%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">位置无关代码的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rel-dyn%E6%AE%B5%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.3.</span> <span class="toc-text">.rel .dyn段简单介绍</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#relocate%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">relocate代码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#gd%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%86%E6%9E%90"><span class="toc-number">3.1.</span> <span class="toc-text">gd结构体分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">代码流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%EF%BC%9AARM-ABI%E7%BA%A6%E5%AE%9A"><span class="toc-number">3.3.</span> <span class="toc-text">基础：ARM ABI约定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E4%BB%A3%E7%A0%81-main"><span class="toc-number">3.4.</span> <span class="toc-text">总体代码-_main</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#board-init-f-alloc-reserve-%E5%88%86%E6%9E%90"><span class="toc-number">3.5.</span> <span class="toc-text">board_init_f_alloc_reserve()分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#board-init-f-init-reserve%E5%88%86%E6%9E%90"><span class="toc-number">3.6.</span> <span class="toc-text">board_init_f_init_reserve分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#board-init-f-%E5%88%86%E6%9E%90"><span class="toc-number">3.7.</span> <span class="toc-text">board_init_f()分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#relocate-code%E5%88%86%E6%9E%90"><span class="toc-number">3.8.</span> <span class="toc-text">relocate_code分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#relocate-vectors%E5%88%86%E6%9E%90"><span class="toc-number">3.9.</span> <span class="toc-text">relocate_vectors分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%85%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">待处理问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E5%BC%95%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">参考引用</span></a></li></ol></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">行走的康康.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" color="246,246,246" opacity="0.5" zIndex="-2" count="50" src="//cdn.jsdelivr.net/npm/canvas-nest.js/dist/canvas-nest.min.js"></script><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>
<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>OK6410 u-boot_1.1.6分析 | 行走的康康</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 6.1.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">OK6410 u-boot_1.1.6分析</h1><a id="logo" href="/.">行走的康康</a><p class="description">静下心来,不要浮躁</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">OK6410 u-boot_1.1.6分析</h1><div class="post-meta">2022-03-22<span> | </span><span class="category"><a href="/categories/U-Boot/">U-Boot</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.6k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 17</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><p>这段时间因为疫情在家，失业了也没有什么其他的事情，想着好好学习一下u-boot相关内容。</p>
<p>正好手头上有之前买了然后吃灰的OK6410，根据网上的相关资料着手移植到u-boot 2018版本，折腾了快半个月的时间还是没有成功，每次<code>bl _main</code>后就会挂掉，不知道具体原因很是困惑，也找了一些调试方法，比如通过Jlink直接调试，通过Jlink-gdb-server，最后没怎么搞明白如何调试，但是发现运行后进入了<code>data_abort</code>异常位置。分析应该是relocate出现问题，也找了很久无果，然后想着好好分析一些飞凌提供的旧版本的u-boot。</p>
<span id="more"></span>

<h1 id="开发板硬件资源"><a href="#开发板硬件资源" class="headerlink" title="开发板硬件资源"></a>开发板硬件资源</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">飞凌OK6410开发板</span><br><span class="line">    DDR:    256MB 型号：K4X1G163PC (64Mx16bit=128MB) * 2</span><br><span class="line">    NAND:    1GB    型号：MT29F16G08ABACAWP, SLC, PageSize=4K</span><br><span class="line">    SD:        SD/MMC Host Controller 使用channel 0</span><br><span class="line"> </span><br><span class="line">    LCD:     WXCAT43-TG3#001, 4.3寸 屏</span><br><span class="line">    Ethernet: DM9000A</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h1 id="如何编译"><a href="#如何编译" class="headerlink" title="如何编译"></a>如何编译</h1><p>根据根目录下的Makefile文件</p>
<img src="https://nas.littlekang.xyz:9000/markdown/2022-03/1918_1929-gLh9WEIIE1HN5smc.png" alt="image-20220319181929608" style="zoom:200%;" />

<p>编译方式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用的工具链是飞凌提供的，gcc version 4.3.2</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">指定交叉工具链</span></span><br><span class="line">export CROSS_COMPILE=arm-linux-</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置u-boot</span></span><br><span class="line">    #从sd卡启动</span><br><span class="line">    make forlinx_sd_ram256_config</span><br><span class="line"> </span><br><span class="line">    #从nand启动</span><br><span class="line">    make forlinx_nand_ram256_config</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译</span></span><br><span class="line">make -j8</span><br></pre></td></tr></table></figure>

<p><code>mkconfig</code> shell脚本主要的配置：</p>
<img src="https://nas.littlekang.xyz:9000/markdown/2022-03/1918_2906-cYQtGlxCqxMKTmct.png" alt="image-20220319182906640" style="zoom:200%;" />

 

<h1 id="从SD卡启动"><a href="#从SD卡启动" class="headerlink" title="从SD卡启动"></a>从SD卡启动</h1><h2 id="u-boot怎么放入SD卡"><a href="#u-boot怎么放入SD卡" class="headerlink" title="u-boot怎么放入SD卡"></a>u-boot怎么放入SD卡</h2><p>根据<code>S3C6410_Internal_ROM_Booting.pdf</code>的启动流程说明：</p>
<p>s3c6410启动时，iROM中的<strong>BL0</strong>会加载sd卡中的u-boot前8K到iRAM</p>
<img src="https://nas.littlekang.xyz:9000/markdown/2022-03/1917_5546-FYMiuXTxrq73GAgh.png" alt="image-20220319175545735" style="zoom:200%;" />

 

<h2 id="怎么将u-boot分成两部分-BL1-BL2"><a href="#怎么将u-boot分成两部分-BL1-BL2" class="headerlink" title="怎么将u-boot分成两部分(BL1,BL2)"></a>怎么将u-boot分成两部分(BL1,BL2)</h2><p>sd卡的分区方式(u-boot，kernel，rootfs等如何存放)：<br>本人使用的时SHDC sd卡，所以分区格式为</p>
<img src="https://nas.littlekang.xyz:9000/markdown/2022-03/1918_0259-VkgsbFnLVTlgnd35.png" alt="image-20220319180259352" style="zoom:200%;" />

 

<p><strong>有点疑惑的是这个<code>Signature</code>分区，作用是什么??</strong></p>
<p>所以想看看sd卡的u-boot如何烧写Nand Flash中的 u-boot</p>
<p>如何烧写：</p>
<ul>
<li><p>方法1：使用飞凌提供的<code>SD_Write.exe</code>工具，工具将会按照sd卡的类型写入数据<br>注意u-boot源码中相关参数的定义，比如u-boot的大小，ENV的大小需要和SD_Write.exe定义的一致，因为BL1在拷贝BL2的时候需要知道BL2的存放地址，<br>根据源码中<code>movi.c</code> 和要求的分区格式计算：参考[BL1如何搬迁BL2到SDRAM](# BL1如何搬迁BL2到SDRAM)<br><strong>因不知道飞凌提供工具对应的参数，所以不建议使用此方法</strong>。</p>
</li>
<li><p>方法2：Linux下使用<code>dd</code>命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第一部分:</span></span><br><span class="line">dd if=u-boot.bin of=./bl1.bin bs=512 count=16</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第二部分:</span></span><br><span class="line">cp u-boot.bin ./bl2.bin</span><br></pre></td></tr></table></figure>
<p>烧写shell脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">SDCARD=/dev/sdb</span><br><span class="line">SPL_BOOT=bl1.bin</span><br><span class="line">UBOOT=u-boot.bin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">保留大小, SDHC=1025, SD=1</span></span><br><span class="line">RES_SZ=1025</span><br><span class="line"></span><br><span class="line">SECTOR_SIZE=512        #Block大小</span><br><span class="line">SIG_SZ=1            #signature block-size, 512byte</span><br><span class="line">BL1_SZ=16            #BL1 block-size, 8K</span><br><span class="line">BL2_SZ=512             #BL2 block-size, 256K</span><br><span class="line">ENV_SZ=32           #ENV block-size, 16K</span><br><span class="line"></span><br><span class="line">BL1_SIZE=`expr $BL1_SZ \* $SECTOR_SIZE / 1024`</span><br><span class="line">BL2_SIZE=`expr $BL2_SZ \* $SECTOR_SIZE / 1024`</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sd卡容量</span></span><br><span class="line">SDCARD_SECTORS=`cat /sys/block/$&#123;SDCARD##*/&#125;/size`</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">BL1 BL2写入位置</span></span><br><span class="line">START_BL1_POS=$(($SDCARD_SECTORS-$RES_SZ-$SIG_SZ-$BL1_SZ))</span><br><span class="line">START_BL2_POS=$(($START_BL1_POS-$ENV_SZ-$BL2_SZ))</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打印结果</span></span><br><span class="line">print_result()</span><br><span class="line">&#123;</span><br><span class="line">    if [ &quot;$1&quot; == 0 ]; then</span><br><span class="line">        echo &quot;success&quot;</span><br><span class="line">    else</span><br><span class="line">        echo &quot;failed&quot;</span><br><span class="line">        exit -1</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">需要root权限，如果没有提示信息</span></span><br><span class="line">if [ `whoami` != &quot;root&quot; ];then</span><br><span class="line">    echo &quot;Need root permision to execute the script!&quot;</span><br><span class="line">    exit</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">BL1创建</span></span><br><span class="line">echo &quot;Create bl1.bin....&quot;</span><br><span class="line">rm -rf bl1.bin</span><br><span class="line">dd if=u-boot.bin of=bl1.bin bs=512 count=16</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">判断sd卡是否存在</span></span><br><span class="line">echo &quot;sd/mmc: $SDCARD&quot;</span><br><span class="line">if [ ! -b &quot;$SDCARD&quot; ]; then</span><br><span class="line">cat &lt;&lt; EOF</span><br><span class="line">no device found</span><br><span class="line">Usage: $0 &lt;sd-dev&gt; [sd-type]</span><br><span class="line">     defalutly, &lt;sd-dev&gt; is /dev/sdb, sd-type is &quot;sdhc&quot; in (&quot;sdhc&quot;,&quot;sd&quot;)</span><br><span class="line">EOF</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写入数据</span></span><br><span class="line">echo -n &quot;write bl1 to sd/mmc at offset: $START_BL1_POS block-size: $BL1_SZ size: $BL1_SIZE K...  &quot;</span><br><span class="line">dd bs=$SECTOR_SIZE seek=$START_BL1_POS if=/dev/zero of=$SDCARD count=$BL1_SZ  &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">dd bs=$SECTOR_SIZE seek=$START_BL1_POS if=$SPL_BOOT of=$SDCARD count=$BL1_SZ  &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">print_result &quot;$?&quot;</span><br><span class="line"></span><br><span class="line">echo -n &quot;write bl2 to sd/mmc at offset: $START_BL2_POS block-size: $BL2_SZ size: $BL2_SIZE K...  &quot;</span><br><span class="line">dd bs=$SECTOR_SIZE seek=$START_BL2_POS if=/dev/zero of=$SDCARD count=$BL2_SZ &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">dd bs=$SECTOR_SIZE seek=$START_BL2_POS if=$UBOOT of=$SDCARD count=$BL2_SZ  &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">print_result &quot;$?&quot;</span><br><span class="line"></span><br><span class="line">sync</span><br><span class="line">exit  0</span><br></pre></td></tr></table></figure>

<p>参考:</p>
<blockquote>
<p>代码烧写部分：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Golden_Chen/article/details/86644879">https://blog.csdn.net/Golden_Chen/article/details/86644879</a></p>
</blockquote>
</li>
</ul>
<h2 id="BL1流程"><a href="#BL1流程" class="headerlink" title="BL1流程"></a>BL1流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">reset                        #cpu/s3c64xx/start.S</span><br><span class="line">    cpu_init_crit</span><br><span class="line">    bl lowlevel_init        #board/samsung/smdk6410/lowlevel_init.S</span><br><span class="line"></span><br><span class="line">    #判断运行的代码是否已经relocate;  start.S</span><br><span class="line">    #BL1运行在iRAM,所以没有relocate,执行movi_bl2_copy</span><br><span class="line"></span><br><span class="line">    #搬迁BL2到SDRAM</span><br><span class="line">    bl movi_bl2_copy        #cpu/s3c64xx/movi.c</span><br><span class="line"></span><br><span class="line">    b after_copy            #cpu/s3c64xx/start.S</span><br><span class="line"></span><br><span class="line">    skip_hw_init</span><br><span class="line">    stack_setup  </span><br><span class="line">    clear_bss</span><br><span class="line"></span><br><span class="line">    #跳转到BL2</span><br><span class="line">    ldr    pc, _start_armboot    #cpu/s3c64xx/start.S</span><br></pre></td></tr></table></figure>

<h2 id="BL1如何搬迁BL2到SDRAM"><a href="#BL1如何搬迁BL2到SDRAM" class="headerlink" title="BL1如何搬迁BL2到SDRAM"></a>BL1如何搬迁BL2到SDRAM</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#SD卡中的代码 如何搬运 确定了 第二部分在哪里</span><br><span class="line"> </span><br><span class="line">#如何搬运的代码</span><br><span class="line"> </span><br><span class="line">#ifdef CONFIG_BOOT_MOVINAND  // u-boot-1.1.6/cpu/s3c64xx/start.S</span><br><span class="line">    ldr sp, _TEXT_PHY_BASE                                                        </span><br><span class="line">    bl  movi_bl2_copy                                                             </span><br><span class="line">    b   after_copy                                                                </span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">#搬运代码核心</span><br><span class="line">CopyMovitoMem(HSMMC_CHANNEL, MOVI_BL2_POS, MOVI_BL2_BLKCNT, (uint *)BL2_BASE, MOVI_INIT_REQUIRED);</span><br><span class="line">#define CopyMovitoMem(a,b,c,d,e)    (((int(*)(int, uint, ushort, uint *, int))(*((uint *)(TCM_BASE + 0x8))))(a,b,c,d,e)) // 这个代码是 定义在 iTCM 中的</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    HSMMC_CHANNEL       </span><br><span class="line">        0</span><br><span class="line">        用的哪一个channel : 0</span><br><span class="line">    MOVI_BL2_POS       </span><br><span class="line">        #define MOVI_BL2_POS        (MOVI_LAST_BLKPOS - MOVI_BL1_BLKCNT - MOVI_BL2_BLKCNT - MOVI_ENV_BLKCNT)</span><br><span class="line">        从哪个位置搬移 : 全部的块大小(由iROM中的代码算出来,位于signature处) - BL大小(16个sector,由手册决定) - BL2大小(512个,由u-boot决定,所以第二部分最大为256KB) - 环境所占大小(32个,由u-boot决定)</span><br><span class="line">    MOVI_BL2_BLKCNT</span><br><span class="line">        #define MOVI_BL2_BLKCNT     (PART_SIZE_BL / MOVI_BLKSIZE)</span><br><span class="line">        搬移多少个块 : 512个块,256KB</span><br><span class="line">    BL2_BASE           </span><br><span class="line">        #define BL2_BASE        (CFG_PHY_UBOOT_BASE)</span><br><span class="line">        搬到哪里: 0x5FE00000,位于sdram</span><br><span class="line">    MOVI_INIT_REQUIRED   </span><br><span class="line">        0</span><br><span class="line">        是否重新初始化:否</span><br></pre></td></tr></table></figure>

<p>By:  <a target="_blank" rel="noopener" href="https://blog.csdn.net/u011011827">_<em>pop</em></a>， <a target="_blank" rel="noopener" href="https://blog.csdn.net/u011011827/article/details/114266423">OK6410A 开发板 (三) u-boot-1.1.6 boot 解析</a></p>
<p>BL0中厂商固化的拷贝函数(<code>S3C6410_Internal_ROM_Booting.pdf</code>)：</p>
<img src="https://nas.littlekang.xyz:9000/markdown/2022-03/1918_5609-Zwg0k0TTma2Lzk5I.png" alt="image-20220319185609073" style="zoom:200%;" />

 

<h2 id="BL2流程"><a href="#BL2流程" class="headerlink" title="BL2流程"></a>BL2流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#BL2 是 从_start_armboot开始的: ldr    pc, _start_armboot         #cpu/s3c64xx/start.S</span><br><span class="line"> </span><br><span class="line">_start_armboot:</span><br><span class="line">    .word start_armboot        #cpu/s3c64xx/start.S</span><br><span class="line"> </span><br><span class="line">start_armboot()                #lib_arm/board.c</span><br><span class="line">    #gd_t 结构初始化</span><br><span class="line"> </span><br><span class="line">    #初始化: 函数首地址存放在 init_sequence[] 指针数组</span><br><span class="line">        cpu_init()            #cpu/s3c64xx/cpu.c</span><br><span class="line">        board_init()        #board/samsung/smdk6410.c</span><br><span class="line">        interrupt_init()    #cpu/s3c64xx/interrupts.c</span><br><span class="line"> </span><br><span class="line">        env_init()            #common/env_movi.c  (函数所在文件和启动方式相关)</span><br><span class="line"> </span><br><span class="line">        init_baudrate()        #lib_arm/board.c</span><br><span class="line">        serial_init()        #cpu/s3c64xx/serial.c</span><br><span class="line">        console_init_f()    #common/console.c</span><br><span class="line">        display_banner()    #lib_arm/board.c</span><br><span class="line">        print_cpuinfo()        #cpu/s3c64xx/speed.c</span><br><span class="line">        checkboard()        #board/samsung/smdk6410.c</span><br><span class="line">        dram_init()            #board/samsung/smdk6410.c</span><br><span class="line">        display_dram_config()#lib_arm/board.c</span><br><span class="line"> </span><br><span class="line">    flash_init()            #board/samsung/flash.c</span><br><span class="line">    lcd_setmem()            #common/lcd.c</span><br><span class="line">    mem_malloc_init()        #lib_arm/board.c</span><br><span class="line">    nand_init()                #board/samsung/smdk6410.c</span><br><span class="line"> </span><br><span class="line">    #sd/mmc控制器初始化  (和启动方式相关)</span><br><span class="line">    movi_set_capacity()</span><br><span class="line">    movi_set_ofs()</span><br><span class="line">    movi_init()                #cpu/s3c64xx/movi.c</span><br><span class="line"> </span><br><span class="line">    env_relocate()            #common/env_common.c</span><br><span class="line"> </span><br><span class="line">    #设备相关驱动初始化</span><br><span class="line">    devices_init()            #common/devices.c</span><br><span class="line"> </span><br><span class="line">    jumptable_init()        #common/exports.c</span><br><span class="line">    console_init_r()        #common/console.c</span><br><span class="line">    enable_interrupts()        #cpu/s3c64xx/interrupts.c  </span><br><span class="line">    board_late_init()        #board/samsung/smdk6410.c</span><br><span class="line">    eth_initialize()        #net/eth.c</span><br><span class="line"> </span><br><span class="line">    #main循环</span><br><span class="line">    main_loop()                #common/main.c</span><br><span class="line">        #还没有超时或被中断</span><br><span class="line">        if (bootdelay &gt;= 0 &amp;&amp; s &amp;&amp; !abortboot (bootdelay)) &#123;</span><br><span class="line">            #解析bootcmd命令</span><br><span class="line">            parse_string_outer()    #common/hush.c</span><br><span class="line">                run_list                 #common/hush.c</span><br><span class="line">                    run_list_real         #common/hush.c</span><br><span class="line">                        run_pipe_real     #common/hush.c</span><br><span class="line">                            #查找&amp;执行命令</span><br><span class="line">                            cmdtp = find_cmd(child-&gt;argv[i]); #common/command.c</span><br><span class="line">                                #cmd_tbl_t *cmdtp_temp = &amp;__u_boot_cmd_start;</span><br><span class="line">                                #命令列表首地址为__u_boot_cmd_start ，链接器脚本board/samsung/smdk6410/u-boot.lds中定义</span><br><span class="line">                                __u_boot_cmd_start = .;</span><br><span class="line">                                .u_boot_cmd : &#123; *(.u_boot_cmd) &#125;</span><br><span class="line">                                __u_boot_cmd_end = .;</span><br><span class="line"> </span><br><span class="line">                            if (cmdtp == NULL) &#123;</span><br><span class="line">                                #没有找到命令</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                #执行命令</span><br><span class="line">                                rcode = (cmdtp-&gt;cmd)(cmdtp, flag,child-&gt;argc-i,&amp;child-&gt;argv[i]);</span><br><span class="line">                            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        #被中断</span><br><span class="line">        ARMMenu()            #common/main.c</span><br><span class="line">            #相关菜单选择……</span><br></pre></td></tr></table></figure>

<p>**<code>.u_boot_cmd</code>**定义的位置为：<code>include/command.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//告诉编译器将xxx放在 .u_boot_cmd段</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Struct_Section  __attribute__ ((unused,section (<span class="string">&quot;.u_boot_cmd&quot;</span>)))</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//用于定义命令tab的宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> U_BOOT_CMD(name,maxargs,rep,cmd,usage,help) \</span></span><br><span class="line"><span class="meta">    cmd_tbl_t __u_boot_cmd_##name Struct_Section = &#123;#name, maxargs, rep, cmd, usage, help&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">各个命令通过U_BOOT_CMD宏来定义，链接器将各个不同功能cmd_tab,</span></span><br><span class="line"><span class="comment">从__u_boot_cmd_start起始地址按顺序的存放；</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">通过find_cmd()函数查找命令：</span></span><br><span class="line"><span class="comment">cmd_tbl_t *cmdtp_temp = &amp;__u_boot_cmd_start;</span></span><br><span class="line"><span class="comment">for (cmdtp = &amp;__u_boot_cmd_start; cmdtp != &amp;__u_boot_cmd_end; cmdtp++) &#123;</span></span><br><span class="line"><span class="comment">    if (strncmp (cmd, cmdtp-&gt;name, len) == 0) &#123;</span></span><br><span class="line"><span class="comment">        if (len == strlen (cmdtp-&gt;name))</span></span><br><span class="line"><span class="comment">            return cmdtp;    //完全匹配</span></span><br><span class="line"><span class="comment">        cmdtp_temp = cmdtp;    //简短的命令?</span></span><br><span class="line"><span class="comment">        n_found++;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//U_BOOT_CMD定义命令的格式，如nand相关命令， common/cmd_nand.c</span></span><br><span class="line"> </span><br><span class="line">U_BOOT_CMD(nand, <span class="number">5</span>, <span class="number">1</span>, do_nand,</span><br><span class="line">           <span class="string">&quot;nand    - NAND sub-system\n&quot;</span>,</span><br><span class="line">           <span class="string">&quot;info             - show available NAND devices\n&quot;</span></span><br><span class="line">           <span class="string">&quot;nand device [dev]     - show or set current device\n&quot;</span></span><br><span class="line">           <span class="string">&quot;nand read[.jffs2]     - addr off|partition size\n&quot;</span></span><br><span class="line">           <span class="string">&quot;nand write[.jffs2]    - addr off|partiton size - read/write `size&#x27; bytes starting\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    at offset `off&#x27; to/from memory address `addr&#x27;\n&quot;</span></span><br><span class="line">           <span class="meta">#<span class="keyword">ifdef</span> CFG_NAND_YAFFS_WRITE</span></span><br><span class="line">           <span class="string">&quot;nand write[.yaffs[1]] - addr off|partition size - write `size&#x27; byte yaffs image\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    starting at offset `off&#x27; from memory address `addr&#x27; (.yaffs1 for 512+16 NAND)\n&quot;</span></span><br><span class="line">           <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">           <span class="string">&quot;nand write[.uboot] - addr off|partition size\n&quot;</span></span><br><span class="line">           <span class="string">&quot;nand write[.ok] - sound beep ok\n&quot;</span></span><br><span class="line">           <span class="string">&quot;nand erase [clean] [off size] - erase `size&#x27; bytes from\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    offset `off&#x27; (entire device if not specified)\n&quot;</span></span><br><span class="line">           <span class="string">&quot;nand bad - show bad blocks\n&quot;</span></span><br><span class="line">           <span class="string">&quot;nand dump[.oob] off - dump page\n&quot;</span></span><br><span class="line">           <span class="string">&quot;nand scrub - really clean NAND erasing bad blocks (UNSAFE)\n&quot;</span></span><br><span class="line">           <span class="string">&quot;nand markbad off - mark bad block at offset (UNSAFE)\n&quot;</span></span><br><span class="line">           <span class="string">&quot;nand biterr off - make a bit error at offset (UNSAFE)\n&quot;</span></span><br><span class="line">           <span class="string">&quot;nand lock [tight] [status] - bring nand to lock state or display locked pages\n&quot;</span></span><br><span class="line">           <span class="string">&quot;nand unlock [offset] [size] - unlock section\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>对于飞凌提供的从sd卡启动的固件，上电默认自动烧写所有固件，那么<code>bootcmd</code>是什么呢？</p>
<p>从<code>common/env_movi.c</code>中定义的<code>env_init()</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">env_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//没有定义 ENV_IS_EMBEDDED</span></span><br><span class="line">    gd-&gt;env_addr  = (ulong)&amp;default_environment[<span class="number">0</span>];</span><br><span class="line">    gd-&gt;env_valid = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//common/env_common.c</span></span><br><span class="line">uchar default_environment[] = &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>    CONFIG_BOOTARGS</span></span><br><span class="line">    <span class="string">&quot;bootargs=&quot;</span>    CONFIG_BOOTARGS            <span class="string">&quot;\0&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>    CONFIG_BOOTCOMMAND</span></span><br><span class="line">    <span class="string">&quot;bootcmd=&quot;</span>    CONFIG_BOOTCOMMAND        <span class="string">&quot;\0&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//include/configs/smdk6410.h</span></span><br><span class="line"><span class="comment">//从sd卡启动</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_BOOTCOMMAND  <span class="string">&quot;nand led-start;nand erase;fatload mmc 0:1 0x50008000 u-boot.bin;nand write.uboot 0x50008000 0 0x200000;fatload mmc 0:1 0x50008000 zImage;nand write.e 0x50008000 0x500000 0x500000; fatload mmc 0:1 0x50008000 rootfs.yaffs2; nand write.yaffs2 0x50008000 0x01e00000 $filesize;  nand beep; nand led-end&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//nand led-start;    开始提示：led</span></span><br><span class="line"><span class="comment">//nand erase;    擦除nand flash</span></span><br><span class="line"><span class="comment">//fatload mmc 0:1 0x50008000 u-boot.bin;nand write.uboot 0x50008000 0 0x200000;  烧写u-boot</span></span><br><span class="line"><span class="comment">//fatload mmc 0:1 0x50008000 zImage;nand write.e  0x50008000 0x500000 0x500000;     烧写kernel</span></span><br><span class="line"><span class="comment">//fatload mmc 0:1 0x50008000 rootfs.yaffs2; nand write.yaffs2 0x50008000 0x01e00000 $filesize;  烧写rootfs</span></span><br><span class="line"><span class="comment">//nand beep; nand led-end 结束提示led, beep  </span></span><br></pre></td></tr></table></figure>

<p>启动信息：</p>
<img src="https://nas.littlekang.xyz:9000/markdown/2022-03/1923_2123-o8mzeEfLJMDa40mR.png" alt="image-20220319232123289" style="zoom:200%;" />

 

<h2 id="BL2如何将sd卡中u-boot烧写到nand"><a href="#BL2如何将sd卡中u-boot烧写到nand" class="headerlink" title="BL2如何将sd卡中u-boot烧写到nand"></a>BL2如何将sd卡中u-boot烧写到nand</h2><p>从<code>bootcmd</code>启动命令，知道执行的是<code>nand write.uboot 0x50008000 0 0x200000</code>命令。</p>
<p>从前面<code>.u_boot_cmd</code>的分析，知道<code>nand write.uboot</code>是在common&#x2F;cmd_nand.c中定义， 命令函数是<code>do_nand()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--------------do_nand()分析</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span> <span class="title">nand_info_t</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="type">nand_info_t</span> *nand;</span><br><span class="line">nand = &amp;nand_info[nand_curr_device]; <span class="comment">//nand_curr_device=0</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(cmd, <span class="string">&quot;read&quot;</span>, <span class="number">4</span>) == <span class="number">0</span> || <span class="built_in">strncmp</span>(cmd, <span class="string">&quot;write&quot;</span>, <span class="number">5</span>) == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">/* write */</span></span><br><span class="line">    nand_write_opts(nand, &amp;opts);    <span class="comment">//drivers/nand/nand_util.c  </span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//板子的nand, page-size=4K, 最小write单位为page</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!read &amp;&amp; s != <span class="literal">NULL</span> &amp;&amp; (!<span class="built_in">strcmp</span>(s, <span class="string">&quot;.uboot&quot;</span>)) &amp;&amp; nand-&gt;writesize == <span class="number">4096</span>) &#123;</span><br><span class="line">        	<span class="comment">//困惑：这里addr每次的偏移为啥是2K??</span></span><br><span class="line">        	<span class="comment">/*</span></span><br><span class="line"><span class="comment">        		通过后面看从nand启动时nand_cp.c中的困惑，从网上找到了答案：</span></span><br><span class="line"><span class="comment">        		BL0是将nandflash的块0的前4页中，每页头2K组合成8K，拷贝到steppingstone中的。</span></span><br><span class="line"><span class="comment">        		所以每个page只写SDRAM中的2K内容，下面代码相当于后2K和下一个page前2K是重复的。</span></span><br><span class="line"><span class="comment">        	*/</span></span><br><span class="line">            size=<span class="number">4096</span>;</span><br><span class="line">            nand_write(nand, off, &amp;size, (u_char *)addr);  <span class="comment">//page0-2K</span></span><br><span class="line">        </span><br><span class="line">            off+=<span class="number">4096</span>;</span><br><span class="line">            addr+=<span class="number">2048</span>;</span><br><span class="line">            nand_write(nand, off, &amp;size, (u_char *)addr);  <span class="comment">//page1-2k       </span></span><br><span class="line"> </span><br><span class="line">            off+=<span class="number">4096</span>;</span><br><span class="line">            addr+=<span class="number">2048</span>;</span><br><span class="line">            nand_write(nand, off, &amp;size, (u_char *)addr);  <span class="comment">//page2-2k      </span></span><br><span class="line"> </span><br><span class="line">            off+=<span class="number">4096</span>;</span><br><span class="line">            addr+=<span class="number">2048</span>;</span><br><span class="line">            nand_write(nand, off, &amp;size, (u_char *)addr);  <span class="comment">//page3-2k, BL1=8K, write done.       </span></span><br><span class="line"> </span><br><span class="line">            off+=<span class="number">4096</span>;</span><br><span class="line">            addr+=<span class="number">2048</span>;</span><br><span class="line">            size=<span class="number">1024</span>*<span class="number">1024</span><span class="number">-4</span>*<span class="number">4096</span>;		<span class="comment">//虽然传入参数u-boot的大小是2M,没有使用参数，这里写死了是1M, 1M-已写入的16K							</span></span><br><span class="line">            ret = nand_write(nand, off, &amp;size, (u_char *)addr); <span class="comment">//写BL2+空白未使用</span></span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//--------------------nand_write函数</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">nand_write</span><span class="params">(<span class="type">nand_info_t</span> *info, ulong ofs, ulong *len, u_char *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这里调用的是 mtd-&gt;write接口，它和nand如何关联的？？</span></span><br><span class="line">    <span class="keyword">return</span> info-&gt;write(info, ofs, *len, (<span class="type">size_t</span> *)len, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//info-&gt;write 实际调用得是drivers/nand/nand_base.c中的nand_write</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nand_write - [MTD Interface] NAND write with ECC</span></span><br><span class="line"><span class="comment"> * @mtd:	MTD device structure</span></span><br><span class="line"><span class="comment"> * @to:		offset to write to</span></span><br><span class="line"><span class="comment"> * @len:	number of bytes to write</span></span><br><span class="line"><span class="comment"> * @retlen:	pointer to variable to store the number of written bytes</span></span><br><span class="line"><span class="comment"> * @buf:	the data to write</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NAND write with ECC</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">nand_write</span><span class="params">(<span class="keyword">struct</span> mtd_info *mtd, <span class="type">loff_t</span> to, <span class="type">size_t</span> len,</span></span><br><span class="line"><span class="params">                      <span class="type">size_t</span> *retlen, <span class="type">const</span> <span class="type">uint8_t</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nand_chip</span> *<span class="title">chip</span> =</span> mtd-&gt;priv;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do not allow reads past end of device */</span></span><br><span class="line">    <span class="keyword">if</span> ((to + len) &gt; mtd-&gt;size)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!len)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    nand_get_device(chip, mtd, FL_WRITING);</span><br><span class="line"></span><br><span class="line">    chip-&gt;ops.len = len;</span><br><span class="line">    chip-&gt;ops.datbuf = (<span class="type">uint8_t</span> *)buf;</span><br><span class="line">    chip-&gt;ops.oobbuf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ret = nand_do_write_ops(mtd, to, &amp;chip-&gt;ops);</span><br><span class="line"></span><br><span class="line">    *retlen = chip-&gt;ops.retlen;</span><br><span class="line"></span><br><span class="line">    nand_release_device(mtd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------nand_info_t *nand 如何获得得</span></span><br><span class="line"><span class="type">int</span> nand_curr_device = <span class="number">-1</span>;</span><br><span class="line"><span class="type">nand_info_t</span> nand_info[CFG_MAX_NAND_DEVICE];    <span class="comment">//CFG_MAX_NAND_DEVICE=1</span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nand_chip</span> <span class="title">nand_chip</span>[<span class="title">CFG_MAX_NAND_DEVICE</span>];</span></span><br><span class="line"><span class="type">static</span> ulong base_address[CFG_MAX_NAND_DEVICE] = CFG_NAND_BASE_LIST;    <span class="comment">//CFG_NAND_BASE_LIST=0x70200010 nand控制器首地址</span></span><br><span class="line"> </span><br><span class="line">nand_init()                        	<span class="comment">//driver/nand/nand.c</span></span><br><span class="line">    nand_init_chip()          </span><br><span class="line">        board_nand_init()        	<span class="comment">//cpu/s3c64xx/nand.c</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (nand_scan(mtd, <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mtd-&gt;name)</span><br><span class="line">            mtd-&gt;name = (<span class="type">char</span> *)default_nand_name;    <span class="comment">//default_nand_name=&quot;nand&quot;</span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//问题：nand 和mtd是如何关联的？？？</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>所以可以看出手上的这份文档<code>S3C6410_Internal_ROM_Booting.pdf</code>中关于nand的分区是<strong>有问题的</strong>，</p>
<p>有可能后续修改了而我们没有最新文档。</p>
<p>按照代码，及上面所述BL0的拷贝方式，这里<strong>BL1应该占4Page</strong>， 关于<code>Signature</code>这个段，有些不理解，看了SPV210的 手册<code>S5PV210_iROM_ApplicationNote_Preliminary_20091126.pdf</code>相关的描述，是在<strong>secure boot</strong>的时候才需要的，按照个人理解这里也是一样，所以不需要。</p>
<img src="https://nas.littlekang.xyz:9000/markdown/2022-03/2001_0838-AtMpJDHev4odcigs.png" alt="image-20220320010838834" style="zoom:200%;" />

 

<h1 id="从Nand-Flash启动"><a href="#从Nand-Flash启动" class="headerlink" title="从Nand Flash启动"></a>从Nand Flash启动</h1><h2 id="BL1流程-1"><a href="#BL1流程-1" class="headerlink" title="BL1流程"></a>BL1流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#和从sd卡启动的流程大体相同，只是搬迁BL2不一样</span><br><span class="line"></span><br><span class="line">reset                        #cpu/s3c64xx/start.S</span><br><span class="line">    cpu_init_crit</span><br><span class="line">    bl lowlevel_init        #board/samsung/smdk6410/lowlevel_init.S</span><br><span class="line"></span><br><span class="line">    #判断运行的代码是否已经relocate;  start.S</span><br><span class="line">    #BL1运行在iRAM,所以没有relocate,执行copy_from_nand</span><br><span class="line"></span><br><span class="line">    #搬迁BL2到SDRAM</span><br><span class="line">    bl copy_from_nand        #cpu/s3c64xx/start.S</span><br><span class="line">    	copy_uboot_to_ram	  #cpu/s3c64xx/nand_cp.c</span><br><span class="line"> </span><br><span class="line">    skip_hw_init</span><br><span class="line">    stack_setup  </span><br><span class="line">    clear_bss</span><br><span class="line"></span><br><span class="line">    #跳转到BL2</span><br><span class="line">    ldr    pc, _start_armboot    #cpu/s3c64xx/start.S</span><br></pre></td></tr></table></figure>



<h2 id="BL1如何搬迁BL2到SDRAM-1"><a href="#BL1如何搬迁BL2到SDRAM-1" class="headerlink" title="BL1如何搬迁BL2到SDRAM"></a>BL1如何搬迁BL2到SDRAM</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#cpu/s3c64xx/start.S</span><br><span class="line"></span><br><span class="line">mov	r0, #0x1000</span><br><span class="line">bl	copy_from_nand</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * copy U-Boot to SDRAM and jump to ram (from NAND or OneNAND)</span><br><span class="line"> * r0: size to be compared</span><br><span class="line"> * Load 1&#x27;st 2blocks to RAM because U-boot&#x27;s size is larger than 1block(128k) size</span><br><span class="line"> */</span><br><span class="line">	.globl copy_from_nand</span><br><span class="line">copy_from_nand:</span><br><span class="line">	mov	r10, lr		/* save return address */</span><br><span class="line"></span><br><span class="line">	mov	r9, r0</span><br><span class="line">	/* get ready to call C functions */</span><br><span class="line">	ldr	sp, _TEXT_PHY_BASE	/* setup temp stack pointer */</span><br><span class="line">	sub	sp, sp, #12</span><br><span class="line">	mov	fp, #0			/* no previous frame, so fp=0 */</span><br><span class="line">	mov	r9, #0x1000</span><br><span class="line">	bl	copy_uboot_to_ram</span><br><span class="line"></span><br><span class="line">3:	tst 	r0, #0x0</span><br><span class="line">	bne	copy_failed</span><br><span class="line"></span><br><span class="line">	ldr	r0, =0x0c000000</span><br><span class="line">	ldr	r1, _TEXT_PHY_BASE</span><br><span class="line">1:	ldr	r3, [r0], #4</span><br><span class="line">	ldr	r4, [r1], #4</span><br><span class="line">	teq	r3, r4</span><br><span class="line">	bne	compare_failed	/* not matched */</span><br><span class="line">	subs	r9, r9, #4</span><br><span class="line">	bne	1b</span><br><span class="line"></span><br><span class="line">4:	mov	lr, r10		/* all is OK */</span><br><span class="line">	mov	pc, lr</span><br><span class="line"></span><br><span class="line">copy_failed:</span><br><span class="line">	nop			/* copy from nand failed */</span><br><span class="line">	b	copy_failed</span><br><span class="line"></span><br><span class="line">compare_failed:</span><br><span class="line">	nop			/* compare failed */</span><br><span class="line">	b	compare_failed</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cpu/s3c64xx/nand_cp.c</span></span><br><span class="line"></span><br><span class="line">copy_uboot_to_ram()</span><br><span class="line">    <span class="comment">//MT29F8G08ABABAWP</span></span><br><span class="line">	large_block = <span class="number">2</span>;</span><br><span class="line">	nandll_read_blocks(CFG_PHY_UBOOT_BASE, <span class="number">0x3c000</span>, large_block);	<span class="comment">//读240KB</span></span><br><span class="line">        <span class="keyword">if</span>(large_block == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Read pages */</span></span><br><span class="line">            <span class="comment">//这里为什么是page_shift-1,这样不是覆盖了2K数据？？</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++, buf+=(<span class="number">1</span>&lt;&lt;(page_shift<span class="number">-1</span>))) &#123;</span><br><span class="line">                nandll_read_page(buf, i, large_block);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Read pages */</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">4</span>; i &lt; (<span class="number">0x3c000</span>&gt;&gt;page_shift); i++, buf+=(<span class="number">1</span>&lt;&lt;page_shift)) &#123;</span><br><span class="line">                nandll_read_page(buf, i, large_block);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看代码的时候一直很困惑，不知道为啥第一次读4page的数据，偏移量是<code>page_shift-1</code>, 这样每次会覆盖2K数据。</p>
<p>然后在网上看到了资料：</p>
<blockquote>
<p>从nandflash启动时，<strong>BL0是将nandflash的块0的前4页中，每页头2K组合成8K，拷贝到steppingstone中的</strong>。</p>
<p><strong>BL0是厂家固化好的代码，我们改不了</strong>。如果我们要自己一些启动代码就需要这点。<strong>无论是写入，还是读取这8K的启动代码，也要遵循这样的约定</strong>。</p>
</blockquote>
<p>所以也解决了前面[BL2如何将sd卡中u-boot烧写到nand](# BL2如何将sd卡中u-boot烧写到nand)  “sd卡中的u-boot程序，烧录u-boot到nand时，addr的偏移为啥是2048”的困惑。</p>
<p>这里要感谢<a target="_blank" rel="noopener" href="https://blog.csdn.net/drsonxu">drsonxu</a>的这篇博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/drsonxu/article/details/104251279?spm=1001.2014.3001.5501">关于OK6410的NandFlash启动的一些事实</a> .</p>
<h2 id="BL2流程-1"><a href="#BL2流程-1" class="headerlink" title="BL2流程"></a>BL2流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#和从sd卡启动大致相同，只有</span><br><span class="line">#BL2 是 从_start_armboot开始的: ldr    pc, _start_armboot         #cpu/s3c64xx/start.S</span><br><span class="line"> </span><br><span class="line">_start_armboot:</span><br><span class="line">    .word start_armboot        #cpu/s3c64xx/start.S</span><br><span class="line"> </span><br><span class="line">start_armboot()                #lib_arm/board.c</span><br><span class="line">	#初始化: 函数首地址存放在 init_sequence[] 指针数组</span><br><span class="line">	</span><br><span class="line">	#....参考从sd卡启动</span><br><span class="line"></span><br><span class="line">	#nand控制器初始化</span><br><span class="line">	nand_init();</span><br><span class="line">	</span><br><span class="line">	#....参考从sd卡启动</span><br></pre></td></tr></table></figure>





<h1 id="TODO-待解决问题"><a href="#TODO-待解决问题" class="headerlink" title="TODO:待解决问题"></a>TODO:待解决问题</h1><p><code>nand_write()</code>实际调用的是<code>mtd-&gt;write()</code>, 那么nand驱动是如何和mtd驱动关联的，暂时还没看懂???</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011011827/article/details/114266423">OK6410A 开发板 (三) u-boot-1.1.6 boot 解析</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/drsonxu/article/details/104251279?spm=1001.2014.3001.5501">关于OK6410的NandFlash启动的一些事实</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lock1501/article/details/40590883">s3c6410初始化2G nand flash的一些注意点</a></p>
</blockquote>
</div><div class="tags"><a href="/tags/u-boot/"><i class="fa fa-tag"></i>u-boot</a><a href="/tags/ok6410/"><i class="fa fa-tag"></i>ok6410</a></div><div class="post-nav"><a class="pre" href="/article/50702/">OK6410 u-boot-2018移植-SPL</a><a class="next" href="/article/9443/">u-boot学习笔记-SPL</a></div><script src="https://utteranc.es/client.js" repo="echomlv/blog_comments" issue-term="title" theme="github-light" crossorigin="anonymous" async> </script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa fa-blind"> Contents </i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E6%9D%BF%E7%A1%AC%E4%BB%B6%E8%B5%84%E6%BA%90"><span class="toc-number">1.</span> <span class="toc-text">开发板硬件资源</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91"><span class="toc-number">2.</span> <span class="toc-text">如何编译</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8ESD%E5%8D%A1%E5%90%AF%E5%8A%A8"><span class="toc-number">3.</span> <span class="toc-text">从SD卡启动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#u-boot%E6%80%8E%E4%B9%88%E6%94%BE%E5%85%A5SD%E5%8D%A1"><span class="toc-number">3.1.</span> <span class="toc-text">u-boot怎么放入SD卡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%B0%86u-boot%E5%88%86%E6%88%90%E4%B8%A4%E9%83%A8%E5%88%86-BL1-BL2"><span class="toc-number">3.2.</span> <span class="toc-text">怎么将u-boot分成两部分(BL1,BL2)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BL1%E6%B5%81%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">BL1流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BL1%E5%A6%82%E4%BD%95%E6%90%AC%E8%BF%81BL2%E5%88%B0SDRAM"><span class="toc-number">3.4.</span> <span class="toc-text">BL1如何搬迁BL2到SDRAM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BL2%E6%B5%81%E7%A8%8B"><span class="toc-number">3.5.</span> <span class="toc-text">BL2流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BL2%E5%A6%82%E4%BD%95%E5%B0%86sd%E5%8D%A1%E4%B8%ADu-boot%E7%83%A7%E5%86%99%E5%88%B0nand"><span class="toc-number">3.6.</span> <span class="toc-text">BL2如何将sd卡中u-boot烧写到nand</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8ENand-Flash%E5%90%AF%E5%8A%A8"><span class="toc-number">4.</span> <span class="toc-text">从Nand Flash启动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BL1%E6%B5%81%E7%A8%8B-1"><span class="toc-number">4.1.</span> <span class="toc-text">BL1流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BL1%E5%A6%82%E4%BD%95%E6%90%AC%E8%BF%81BL2%E5%88%B0SDRAM-1"><span class="toc-number">4.2.</span> <span class="toc-text">BL1如何搬迁BL2到SDRAM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BL2%E6%B5%81%E7%A8%8B-1"><span class="toc-number">4.3.</span> <span class="toc-text">BL2流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TODO-%E5%BE%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">TODO:待解决问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">6.</span> <span class="toc-text">参考</span></a></li></ol></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">行走的康康.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" color="246,246,246" opacity="0.5" zIndex="-2" count="50" src="//cdn.jsdelivr.net/npm/canvas-nest.js/dist/canvas-nest.min.js"></script><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>